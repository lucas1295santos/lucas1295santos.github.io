<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Lucas Oliveira dot Tech</title><description>Tech blog about Swift and Engineering topics</description><link>https://lucas1295santos.github.io/</link><language>en</language><lastBuildDate>Tue, 7 Jul 2020 21:01:00 -0300</lastBuildDate><pubDate>Tue, 7 Jul 2020 21:01:00 -0300</pubDate><ttl>250</ttl><atom:link href="https://lucas1295santos.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/async-tests</guid><title>Testing asynchronous code</title><description>When you are starting out on testing your code, you might find asynchronous methods a little bit tricky to test. &lt;br&gt;&lt;/br&gt; But do not worry, *XCTestExpectation* got you covered if you want to assert that an async block *will* execute, or even assert that it *will not* execute.</description><link>https://lucas1295santos.github.io/posts/async-tests</link><pubDate>Tue, 7 Jul 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Testing asynchronous code</h1><p>When you are starting out on testing your code, you might find asynchronous methods a little bit tricky to test.</p><p>But do not worry, <code>XCTestExpectation</code> got you covered if you want to assert that an async block <strong>will</strong> execute, or even assert that it <strong>will not</strong> execute.</p><p>In this post, I'll show you a really common case where you'll want to test an asynchronous method, and how to use <code>XCTestExpectation</code> to create an expectation that a block will be executed on the future, and how to create an inverted expectation to assert that a block will not be executed on the future.</p><h2>The use case</h2><p>Let's say that you are creating a feature that displays information about an item that your app sells. This feature will download the item details from an endpoint on a server whenever the user selects an item from a list. Then you will get the item ID and make an HTTP request to this endpoint to retrieve the item details. But to be more efficient on data usage, you also should cache every item fetched, so if the user wants to see details of an item that was already cached, instead of fetching it from the endpoint, you'll return the cached item.</p><p>To achieve this goal, this feature will have an <code>ItemWorker</code> class. It's objective is to return an item, given an ID. This class will contain the mechanism to get the item from a cache through a <code>CacheRepository</code> or, request it to the endpoint using <code>Network</code>.</p><p>This is a possible implementation of this class:</p><pre><code class="language-swift">final class ItemWorker {
    private let network: NetworkProtocol
    private let cache: CacheRepositoryProtocol
    
    init(
        network: NetworkProtocol = Network.shared,
        cache: CacheRepositoryProtocol = CacheRepository.shared
    ) {
        self.network = network
        self.cache = cache
    }
    
    func requestItem(withID id: String, completion: @escaping (Result&lt;Item, Error&gt;) -&gt; Void) {
        // If the cache contains the item, return the item
        if let cachedItem: Item = cache.get(forKey: id) {
            completion(.success(cachedItem))
        } else {
            let request = ItemRequest.itemByID(id: id)
            // Request an item passing the ID
            network.request(request) { [weak self] (result: Result&lt;Item, Error&gt;) in
                if case let Result.success(item) = result {
                    // Cache the item if succeded
                    self?.cache.set(item: item, forKey: item.id)
                }
                // Return what was fetched
                completion(result)
            }
        }
    }
}
</code></pre><p>Notice on this example that <code>Network</code> and <code>CacheRepository</code> are <strong>singletons</strong>, but however, I didn't use their shared instance directly. I used a <strong>Dependency injection</strong> technique to make <code>ItemWorker</code> depend on protocols instead. So this way, when we test this class, we can create mocked-up classes that conform to <code>NetworkProtocol</code> and <code>CacheRepositoryProtocol</code> that give us full control to test any network scenario or cache state that we want. If you never heard of this concept, I highly recommend that you read <a href="https://martinfowler.com/articles/injection.html#FormsOfDependencyInjection">this definition from Martin Fowler</a>. Mastering dependency injection will take your testing abilities to a whole new level.</p><p>If you need a little bit more of context to understand my implementation of <code>ItemWorker</code>, you can see the definition of the <code>NetworkProtocol</code>, <code>CacheRepositoryProtocol</code>, <code>ItemRequest</code> and <code>Item</code> bellow.</p><pre><code class="language-swift">protocol NetworkProtocol {
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void)
}

protocol CacheRepositoryProtocol {
    func get&lt;T: Codable&gt;(forKey: String) -&gt; T?
    func set&lt;T: Codable&gt;(item: T, forKey: String)
}

enum ItemRequest: NetworkRequest {
    case itemByID(id: String)
}

struct Item: Codable {
    let id: String
    let name: String
}
</code></pre><h2>XCTExpectation</h2><p>Now that we have an <code>ItemWorker</code> that meets the requirements, we should write a test to assert that the requirements are indeed met. Our worker class will fetch the <code>Item</code> from the network only if the <code>Item</code> is not cached.</p><p>First, we will define our test cases. I like to be really descriptive, using the function names to state what is being tested, and what should happen. So if in a future point of time this test fails, it is easy to understand what is broken.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    // Sut means subject under test. It is what we are testing here.
    private lazy var sut = ItemWorker()
    
    func test_requestItem_itemIsNotCached_expectRequestingItem() {

    }
    
    func test_requestItem_itemIsCached_expectNotRequestingItem() {

    }
}
</code></pre><p>Then, we should mock-up <code>Network</code> and <code>CacheRepository</code>, because we can't have our test to rely on network availability or cache state on the testing device. A good test should always pass if the code is correct, and it should always fail if the code is incorrect.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    let network = NetworkSpy()
    let cache = CacheRepositoryMock()
    private lazy var sut = ItemWorker(network: network, cache: cache)
    
    func test_requestItem_itemIsNotCached_expectRequestingItem() {

    }
    
    func test_requestItem_itemIsCached_expectNotRequestingItem() {

    }
}

final class NetworkSpy: NetworkProtocol {
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) {

    }
}

final class CacheRepositoryMock: CacheRepositoryProtocol {
    var cachedObjectToBeReturned: Codable?
    
    func get&lt;T: Codable&gt;(forKey: String) -&gt; T? {
        return cachedObjectToBeReturned as? T
    }
    
    func set&lt;T: Codable&gt;(item: T, forKey: String) {}
}
</code></pre><p>Note how I added the property <code>cachedObjectToBeReturned</code> to easily control a hypothetical scenario of the <code>CacheRepository</code> state.</p><p>Now we are ready to implement our test cases. Let's begin from the case where there is no cache, and <code>ItemWorker</code> should fetch it from the <code>Network</code>. And we'll do it using <code>XCTestExpectation</code>.</p><p>A <code>XCTestExpectation</code> is a promise that you are creating now to be fulfilled in the future (using <code>expectation.fulfill()</code>). It is meant to be used paired with the method <code>wait(for expectations: , timeout:)</code> that asserts that all the expectations are fulfilled in a given time interval. Take a look at the implementation of the first test case, so you can understand what that means. You can also read the <a href="https://developer.apple.com/documentation/xctest/asynchronous_tests_and_expectations/testing_asynchronous_operations_with_expectations">docs from Apple</a>.</p><pre><code class="language-swift">// First we adapted our mocked up Network to fulfill an expectation when something is requested
final class NetworkSpy: NetworkProtocol {
    var requestCompleteExpectation: XCTestExpectation?
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) {
        requestCompleteExpectation?.fulfill()
    }
}

// ...
final class ItemWorkerTests: XCTestCase {
    // ...
    func test_requestItem_itemIsNotCached_expectRequestingItem() {
        // Creates an expectation that will be fulfilled once the item is requested
        let expectation = XCTestExpectation(description: "itemRequest")
        network.requestCompleteExpectation = expectation
        // Mock up a state where the cache doesn't have the requested item
        cache.cachedObjectToBeReturned = nil
        // Requests
        sut.requestItem(withID: "1234", completion: { _ in })
        // Waits for a second, if the expectation IS NOT fulfilled, fails
        wait(for: [expectation], timeout: 1)
    }
    // ...
}
</code></pre><p>The test above should pass, because: - <code>CacheRepositoryMock</code> returns no item. - <code>NetworkSpy</code> is called, fulfilling the expectation. - The expectation that <code>wait</code> is waiting for, is fulfilled before the timeout of 1 second.</p><p>Now, to the test case where the <code>CacheRepository</code> does have the <code>Item</code> cached, and we should not request it from the <code>Network</code>, we will use the property <code>isInverted</code> from <code>XCTestExpectation</code>. This makes the expectation function the exact opposite way of a non-inverted one. This means that <code>wait(for expectations: , timeout:)</code> now asserts that the timeout expires before the expectation is fulfilled. For inverted expectations, if the expectation is fulfilled, the test fails. And this is perfect to assert that code is not executed in the future.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    // ...
    func test_requestItem_itemIsCached_expectNotRequestingItem() {
        // Creates an expectation that will be fulfilled once the item is requested
        let expectation = XCTestExpectation(description: "itemRequest")
        // Set the expectation to inveted, meaning that we expect it to not be fulfilled
        expectation.isInverted = true
        network.requestCompleteExpectation = expectation
        cache.cachedObjectToBeReturned = Item(id: "1234", name: "Mac")
        
        sut.requestItem(withID: "1234", completion: { _ in })
        // Waits for a second, if the expectation IS fulfilled, fails
        wait(for: [expectation], timeout: 1)
    }
    // ...
}
</code></pre><p>The test above should pass, because: - <code>CacheRepositoryMock</code> returns an item. - The worker returns this item not calling <code>NetworkSpy</code>, so the expectation is never fulfilled. - The 1 second timeout defined on the <code>wait</code> method expires.</p><h2>Pro tip: using reasonable timeouts</h2><pre><code class="language-swift">wait(for: [expectation], timeout: 10)
</code></pre><p>In the code above, if the expectation is not inverted, and it is fulfilled in 1 second, the test will pass without actually waiting the whole 10 seconds. But on the other hand, if it is an inverted expectation, the test will take 10 seconds to end the assertion.</p><p>Having tests that take long to complete is harmful to your project. This is especially important if you work on a large enterprise app, where having tests that clutter the CI/CD machines, decreases team productivity and costs the company money.</p><p>Thank you for reading! I hope this is was an useful learning. Take care and good coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/quick-tip-1</guid><title>Quick tip #1: Array copy-on-write</title><description>I'm on a quest to study data structures in Swift, and one really cool feature that Swift arrays implement is copy-on-write!</description><link>https://lucas1295santos.github.io/posts/quick-tip-1</link><pubDate>Sun, 24 May 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Quick tip #1: Array copy-on-write</h1><p>I'm studying data structures, and its implementations in Swift following the Udacity course <a href="https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011">Data Structures &amp; Algorithms in Swift</a> (I'm on early lessons, but from what I've seen so far, I recommend it). And one really nice thing that I learned on the arrays lesson, is that Swift arrays implement copy-on-write. But what does that mean?</p><p>Copy-on-write is a pattern that aims to save storage or memory allocation whenever it is possible by delaying copying a resource as long as it is possible. The copy only happens when someone writes on that resource, in other words, when someone edit, delete or add any information to it.</p><p>It is way easier to understand with some code, so here it goes.</p><pre><code class="language-swift">var originalArray = [1,2,3]
var copyArray = originalArray

originalArray.withUnsafeBufferPointer { (pointer) in
  print("originalArray: \(pointer)")
}
copyArray.withUnsafeBufferPointer { (pointer) in
  print("copyArray: \(pointer)")
}

print("Editing copyArray...")
copyArray[2] = 20

originalArray.withUnsafeBufferPointer { (pointer) in
    print("originalArray: \(pointer)")
}
copyArray.withUnsafeBufferPointer { (pointer) in
    print("copyArray: \(pointer)")
}
</code></pre><p>In the example above, I use <a href="https://developer.apple.com/documentation/swift/array/2994771-withunsafebufferpointer">withUnsafeBufferPointer</a> to get access to the pointer of the starting address of the array. When the code is executed, it outputs the following:</p><pre><code>originalArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
copyArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
Editing copyArray...
originalArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
copyArray: UnsafeBufferPointer(start: 0x0000600002cd95a0, count: 3)
</code></pre><p>You can see that prior to the edition of <code>copyArray</code> both arrays are stored at the same memory address, and only after I did a write operation on it all the values from <code>originalArray</code> were copied over to another memory address, so than the copy could be edited without changing anything at the original.</p><p>Since this all happens under the hood, in most cases it makes no practical difference if you are aware of this language characteristic. But maybe you have a really specific situation where you want to give more context to the code by reassigning one array to a different name, and now you know that you will be paying basically nothing for it in terms of memory usage.</p><p>Thank you for reading, take care, and good coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/first-post</guid><title>This blog is written in Swift!</title><description>Recently, I discovered [Publish](https://github.com/johnsundell/publish), a static website generator that uses Swift, written by [John Sundell](https://swiftbysundell.com).&lt;br&gt;&lt;/br&gt; The main idea is to declare all the pieces of your website like a *Swift Package*, and then using [Plot](https://github.com/JohnSundell/Plot) to generate HTML code using the type-safety of Swift, and finally using [Ink](https://github.com/JohnSundell/Ink) to render posts written in **Markdown**. (like this one!) &lt;br&gt;&lt;/br&gt; It may sound like a lot of tools to handle, but in reality, Publish already does most of the work for you.</description><link>https://lucas1295santos.github.io/posts/first-post</link><pubDate>Mon, 20 Apr 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>This blog is written in Swift!</h1><p>Recently, I discovered <a href="https://github.com/johnsundell/publish">Publish</a>, a static website generator that uses Swift, written by <a href="https://swiftbysundell.com">John Sundell</a>. The main idea is to declare all the pieces of your website like a <em>Swift Package</em> and then using <a href="https://github.com/JohnSundell/Plot">Plot</a> to generate HTML code using the type-safety of Swift, and finally using <a href="https://github.com/JohnSundell/Ink">Ink</a> to render posts written in <strong>Markdown</strong>. (like this one!) It may sound like a lot of tools to handle, but in reality, Publish already does most of the work for you.</p><p>Before digging into how Publish works, I highly recommend that you read the README of <a href="https://github.com/johnsundell/publish">Publish's Github</a> to have an overview on the framework, and all the step-by-step of how to <strong>install</strong> and <strong>setup</strong> a starter project.</p><p>It is worth noting that there you can find a <strong>HowTo</strong> folder where the community registers how to do things that they struggled at first but then figured it out.</p><h2>Files structure</h2><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post1_img1.png" alt="File structure" style="width:200px;"/><p>When you start a new <strong>Publish</strong> website, it will create a file structure like the one above. The first thing we'll do is to understand what is the basic website generated.</p><ul><li><em>Package.swift</em> is a file where you should declare dependencies for your project. If you never worked with Swift Package Manager, you can think of this file as a <em>Podfile</em> where you declare the <em>Cocoa pods</em> that you want to import. You also can learn more at this great article at <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager/">Swift by Sundell</a>.</li></ul><ul><li><em>Content</em> is where you'll add posts, audio, video, or any type of content your website is about. This very blog post is currently in this folder.</li></ul><ul><li><em>Output</em> folder is generated after you run <code>publish generate</code>, and <strong>this is the actual website</strong>. You shouldn't really code or add anything here, Publish will generate everything when you use the <code>generate</code> command.</li></ul><ul><li><em>Resources</em> folder is where you can store assets that your pages will use, and <strong>CSS</strong> styles as well. Currently, I have a <em>images</em> and <em>css</em> folders here. The image of the file structure above is stored int this folder.</li></ul><ul><li><em>Sources</em> folder is where you'll code! Currently, there is a folder with your project's name and a <code>main.swift</code> inside.</li></ul><h2>main.swift</h2><p>This file declares your website through a structure that implements <code>Website</code>, and defines the publishing steps for it.</p><pre><code class="language-swift">struct Bla: Website {
    // Website configurations go here
}
</code></pre><p>And outside of the Website defining structure, you'll have the publish step. This is what will be executed on <code>publish deploy</code>.</p><pre><code class="language-swift">try Bla().publish(
  withTheme: .custom,
  additionalSteps: [
    .deploy(using: .git("git@github.com-lucas1295santos:lucas1295santos/lucas1295santos.github.io.git"))
  ]
)
</code></pre><p>On the example above I did a really basic publish workflow, where I use <strong>Github Pages</strong> to host this website and make it available at this domain. I also declare that I want to use a theme called <code>custom</code> to render this website (I'll talk about that in a bit). But this can easily become a robust deployment pipeline if your website needs to.</p><pre><code class="language-swift">try Bla().publish(using: [
    .step1(),
    .step2(),
    .step3()
])
</code></pre><h2>Custom theme</h2><p>To give your website some visual identity, you'll probably want to not use the default theme and create your own. I do this by instantiating a new <code>Theme</code> passing a <code>HTMLFactory</code> and the <strong>CSS</strong> resources that I'll use, making it available as a static variable of <code>Theme</code> just to make it easily accessible on my <strong>main.swift</strong>.</p><pre><code class="language-swift">extension Theme {
    static var custom: Self {
        Theme(
            htmlFactory: CustomHTMLFactory(),
            resourcePaths: ["Resources/css/styles.css"]
        )
    }
}
</code></pre><p>The <code>CustomHTLMFactory</code> on the code above is an implementation of the <code>HTMLFactory</code> protocol that generates the HTML layout for each piece of the website.</p><pre><code class="language-swift">private struct CustomHTMLFactory&lt;Site: Website&gt;: HTMLFactory {
    func makeIndexHTML(for index: Index, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeSectionHTML(for section: Section&lt;Site&gt;, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeItemHTML(for item: Item&lt;Site&gt;, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makePageHTML(for page: Page, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeTagListHTML(for page: TagListPage, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML? {}
    
    func makeTagDetailsHTML(for page: TagDetailsPage, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML? {}
}
</code></pre><p>I'll not dig any deeper on how to use <strong>Plot</strong> to create the HTML layout required on each method from <code>HTMLFactory</code>, but I highly recommend that you take a look at the implementation of the <code>foundation</code> theme (the one that comes with <strong>Publish</strong>) at the file <code>Theme+Foundation.swift</code> on the <code>Publish</code> package. Copy it, try to change it a little bit, and you will get a hang on how it works in no time (especially if you know any HTML).</p><h2>Wrapping up</h2><p>I'm excited about this framework, and it's being a joy to work with it! And I'm still learning everything that it can do, so I'll post more about it as I learn.</p><p>I Hope that this post gives you a good idea of what it is, and how to get started. And besides the documentations that I referenced throughout the post, you might want to check out <a href="https://youtu.be/JqdS-oi96Gk">this hands-on video</a> from Kilo Loco about getting started on Publish.</p><p>Thank you for reading, take care, and good coding!</p>]]></content:encoded></item></channel></rss>