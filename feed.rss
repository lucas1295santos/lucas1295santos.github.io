<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Lucas Oliveira dot Tech</title><description>Topics about Swift and Engineering</description><link>https://lucas1295santos.github.io/</link><language>en</language><lastBuildDate>Wed, 5 May 2021 22:53:59 -0300</lastBuildDate><pubDate>Wed, 5 May 2021 22:53:59 -0300</pubDate><ttl>250</ttl><atom:link href="https://lucas1295santos.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/refactoring</guid><title>Refactoring</title><description>Refactoring is the process of re-writing code with the intent of improving its quality without changing its external behavior. It is a constant effort that an engineering team has to make to keep or improve code quality. This post summarizes a lot of what I learned by refactoring both huge and tiny pieces of the [iFood](https://apps.apple.com/br/app/ifood-delivery-de-comida/id483017239) app.</description><link>https://lucas1295santos.github.io/posts/refactoring</link><pubDate>Wed, 5 May 2021 00:00:00 -0300</pubDate><content:encoded><![CDATA[<img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/refactoring-header.jpeg" alt="Refactoring"/><h1>Refactoring</h1><p>If you never heard the word refactoring before, the <a href="https://en.wikipedia.org/wiki/Code_refactoring">wikipedia definition for it</a> is a good place to start: <em>code refactoring is the process of restructuring existing computer code without changing its external behavior. Refactoring is intended to improve the design, structure, and/or implementation of the software (its non-functional attributes) while preserving its functionality</em>. Even without knowing this definition, you are likely already applying refactoring every now and then, being renaming variables, extracting blocks of code to functions, extracting methods to classes, or modularizing classes that belong together to their own package.</p><h2>Refactor cost</h2><p>Although refactoring is a positive thing, as its objective is to improve the quality of the target code, refactoring a piece of code is not always feasible.</p><p>Refactoring has a significant cost because it demands developer working hours that won't translate directly into business impact: new functionalities, enabling new businesses, improvements on user experience. Instead, the impact of refactoring is indirect, and will only make a difference in the long run when developers will have an easier time changing that code, resulting in fewer bugs and faster deliveries. And even then, it might go under the radar if people are unable to correlate the success of the team to this well-laid foundation that was crafted in the past, so be sure to mention it to the team, and give credit where credit is due.</p><p>The software we write (mostly) has the objective to enable a business, thus the time and money available for the crafting of this software are constrained by the available budget and market timings related to the business's products. The nature of this relation will create cycles where functionality is rapidly added and technical debt is accumulated, and cycles where technical debt must be paid for and functionality can't be added as quickly.</p><p>Even with good and well-defined architecture, an efficient process of code-review in place, a coherent code style, and developers applying all the good coding practices, technical debt will still be created as features are added and evolved, but the debt will grow slower than it would if you didn't care about code quality. In the end, the good practices are there to slow down the increase of debt, so the happy cycle where functionality can be added blazing-fast lasts longer.</p><p>All in all, refactoring involves a trade-off between velocity now and velocity in the long term. And it is our responsibility as developers to continuously evaluate this trade-off, communicate it to the stakeholders, and when necessary, advocate for large refactors. Martin Fowler has written an awesome article about this subject called <a href="https://www.martinfowler.com/articles/is-quality-worth-cost.html">Is High Quality Software Worth the Cost?</a>, that in my opinion is a must-read for every software engineer and software engineering manager.</p><hr><p>Albeit having described accumulating and paying the techicall debt as cycles, most of the time it won't happen as discretely as that. Stopping a whole product development team for an extensive period to work exclusively on code quality improvements is less than desirable, and for startups with smaller teams, it may not even be possible to do so.</p><p>With time, as code quality decays, features take longer to be implemented, tasks are forever postponed because of technical limitations, bugs occur frequently, and fixing then seems beyond hope as more will just pop out. This can easily become a vicious cycle as the developers will only make the code even worse by adding more and more stuff to it, and doing all kinds of quick-fixes and workarounds (<a href="https://www.urbandictionary.com/define.php?term=Gambiarra">gambiarra</a> as we say in Brazil) to get things done. Sometimes the only way out of this messy code swamp is to go for a total rewrite and start all over again in a clean sheet, but as we all know this is tough.</p><p>Not only a big rewrite is a lot of work, but it can also be a big hit to the team morale as the pressure to finish it fast and start shipping new features mounts.</p><h2>Maintaining code quality</h2><p>The ideal way to go about it is to never let things get so far out of hand to get to this doomed code state. Continous refactor and caring will go a long way to maintain the code in good quality. Of course, that doesn't mean that you'll never have to engage in a huge refactor or a rewrite again, sometimes the business evolves in a way that requirements change or takes gigantic proportions that weren't planned, and that's all fair and square.</p><p>The book <a href="https://www.amazon.com/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052">The Pragmatic Programmer</a> has a section about Software Entropy, and they make a beautiful analogy that bad code is like a building with broken windows. The feeling of abandonment will quickly spread among the developers, in a way that no one will try to repair it, or even take care to not damage it further. The remedy proposed by the authors is to not leave broken windows: fix issues as soon as you see them, or at least document the flaws and work on them later (later in this context means <em>asap</em>, not never). It is important to make a statement that that codebase is not abandoned.</p><p>Most of the refactoring is better done alongside <em>product-driven</em> tasks. You can utilize that you are working on a context anyway, and improve it by refactoring the bits that you found hard to understand, or that weren't flexible enough to accommodate your new use-case.</p><p>The book <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a> makes a simple analogy to this attitude comparing it to a Boy Scout rule to always leave the camp cleaner than found. With enough people with this mindset, code quality can be improved over time.</p><h2>Healthy team, healthy code</h2><p>Keeping a healthy codebase is not a task to be tackled by an individual, refactoring messy chunks of code may be impossible without a supporting team. The improvements made by one person can be quickly dimmed by other developers going in the opposite direction.</p><p>To be able to engage and keep developers comfortable in taking code quality seriously, it is important to have the whole team stand by it.</p><p>The engineering team should be supporting each other by reviewing code, designing solutions together, pair programming, keeping track of technical debt, and backing each other up to keep the shipping business impact while making code refactors.</p><p>Management has to be understanding by giving the development team the time and space necessary to keep deliverying at high quality and to shield the team from unnecessary feature demands.</p><p>Product managers and designers have to be aware of technical complexity and be versatile to keep balance on what is an amazing product and what is simple to develop.</p><h2>Takeaways</h2><ul><li>Code decays even if you are in a really good team with an excellent tech stack, routine refactoring (housekeeping) is part of the job.</li><li>It's easier and safer to change good code, so refactoring is not a waste of time, it is an investment of it.</li><li>Your non-technical colleagues may be unaware of the importance of refactoring. Explain to them how flexible and scalable the code became, praise your teammates when they do take on a refactoring quest.</li><li>Constantly improving code quality is easier than rewriting it every now and then.</li><li>Maintaining a health codebase is a collective challenge; keeping the team engaged in applying good practices, code reviewing, refactoring, and so on, is as important (if not more) as the technical side of it.</li></ul><h2>Beyond this article</h2><p>Refactoring is a broad subject, so I'll be writing more about it. Next time, I'll go about hands-on refactoring techniques.</p><p>The book <a href="https://martinfowler.com/books/refactoring.html">Refactoring Improving the Design of Existing Code</a> from Martin Fowler and Kent Beck is one of the main references on refactoring. For a bitesize read, <a href="https://refactoring.guru/refactoring">Refactoring Guru</a> has awesome, easy to understand and applicable tips and tricks.</p><h2>Thanks for reading!</h2><p>Liked this content? I always announce new articles on my <a href="https://twitter.com/oliveira__lucas">Twitter Account</a>. Suggestions, feedback, and corrections are always welcome.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/equatable-enums</guid><title>Quick tip #3: Equatable enums in Swift</title><description>Enumerations is one of Swift's coolest features for its versatility in representing a group of related values. They can become even more versatile and expressive combined with protocols such as `Equatable`. This short article shows some tricks to do so.</description><link>https://lucas1295santos.github.io/posts/equatable-enums</link><pubDate>Tue, 23 Feb 2021 00:00:00 -0300</pubDate><content:encoded><![CDATA[<img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/equatable-enums-header.png" alt="Equatable enums in Swift"/><h1>Quick tip #3: Equatable enums in Swift</h1><p>Enumerations is one the Swift's coolest features for its versatility in representing a group of related values. They can become even more versatile and expressive combined with protocols such as <code>Equatable</code>. This short article shows some tricks to do so.</p><p>This article assumes that you know what an enum is in Swift. If you are not sure about that, I highly recommend you to read the <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html#ID147">Swift docs on Enums</a> and <a href="https://www.swiftbysundell.com/basics/enums/">this post by John Sundell</a> that will cover all the basics and some more.</p><h2>Comparing enums</h2><p>Since an enum represents a finite set of options or states, we often want to compare values between enums, and the main way of doing that is using a <code>switch</code> statement like represented below:</p><pre><code class="language-swift">enum CameraPermissionStatus {
    case granted
    case notDetermined
    case denied
    case restricted
}

func presentCameraScene(with status: CameraPermissionStatus) {
    switch status {
    case .granted:
        routeToCameraScene()
    case .notDetermined:
        presentCameraPermissionAlert()
    case .denied:
        presentSystemPermissionsSettings()
    case .restricted:
        presentRestrictedAccessDialog()
    }
}
</code></pre><h2>Using switch</h2><p>Usually, you want to do a specific action for each enum case, that's why a <code>switch</code> statement is so fitting. Only in different cases like testing, you are interested in a single case, so a direct comparison would be better.</p><pre><code class="language-swift">func test_getCameraPermission_expectedToBeGranted() {
    permissionProviderStub.permissionToBeReturned = .granted

    let permission = sut.getCameraPermission()
        
    XCTAssertEqual(permission, .granted)
}
</code></pre><p>A piece of cake, isn't it?</p><p>Things can become a little tricky when the enum has an associated value.</p><pre><code class="language-swift">enum FeedbackAction {
    case toast(message: String)
    case alert(title: String, message: String)
    case retryConnection
}

func test_getFeedback_whenErrorIsInvalidCard_expectAlert() {
    let sut = PurchaseError(code: "INVALID_CARD")
    
    let feedback = sut.getFeedback()
    
    XCTAssertEqual(feedback, .alert)
}
</code></pre><p>Now if you try to do a similar test, like the one above, with this enum you'll get the error <code>Global function 'XCTAssertEqual(_:_:_:file:line:)' requires that 'FeedbackAction' conform to 'Equatable'</code>. So the obvious way of fixing this test would be to assert inside a <code>switch</code> statement.</p><pre><code class="language-swift">func test_getFeedback_whenErrorIsInvalidCard_expectAlert() {
    let sut = PurchaseError(code: "INVALID_CARD")
    
    let feedback = sut.getFeedback()
    
    switch feedback {
    case .alert(let title, let message):
        XCTAssertEqual(title, "Invalid card")
        XCTAssertEqual(message, "Review card information and try again")
    default:
        XCTFail("Expected alert feedback action")
    }
}
</code></pre><p>Using the <code>switch</code> statement allowed us to assert that the type and all the associated values are matching the expected, at the cost of having to add the <code>XCTFail</code> at the default case as otherwise, the test would pass even without executing the assertions. Remember that a test success is the absence of failures, so a test without asserts is still a success. But what would this test look like if we were to assert the <code>retryConnection</code> case?</p><pre><code class="language-swift">func test_getFeedback_whenErrorIsNoNetwork_expectRetryConnection() {
    let sut = PurchaseError(code: "NO_NETWORK")
    
    let feedback = sut.getFeedback()
    
    switch feedback {
    case .retryConnection:
        break
    default:
        XCTFail("Expected retryConnection feedback action")
    }
}
</code></pre><p>Since the case <code>retryConnection</code> has no associated values, we don't have any assertions to do in the <code>switch</code> statement, so the test would pass by not asserting anything, or fail by the <code>XCTFail</code> on the <code>default</code> case. Besides looking weird, this test isn't clearly following the Arrange, Act, Assert (AAA) pattern since there is no assert.</p><p>If you are not sure what this AAA thing is, <a href="https://blog.ploeh.dk/2013/06/24/a-heuristic-for-formatting-code-according-to-the-aaa-pattern/">this article from Mark Seemann</a> briefly explains it, and gives good examples on how to write tests using this pattern. The AAA pattern is a basic standard for testing in many languages, so it is worth the effort to learn and practice it.</p><h2>Using Equatable</h2><p>A cleaner way of doing the same test would be to make <code>FeedbackAction</code> conform to <code>Equatable</code>.</p><pre><code class="language-swift">enum FeedbackAction: Equatable {
    case toast(message: String)
    case alert(title: String, message: String)
    case retryConnection
}

func test_getFeedback_whenErrorIsInvalidCard_expectAlert() {
    let sut = PurchaseError(code: "INVALID_CARD")
    
    let receivedFeedback = sut.getFeedback()
    
    let expectedFeedback = FeedbackAction.alert(
        title: "Invalid card",
        message: "Review card information and try again"
    )
    XCTAssertEqual(receivedFeedback, expectedFeedback)
}
</code></pre><p>By default when an enum is conforming to equatable, two values are considered equal if they are the same case and if all the associated values are equal.</p><pre><code class="language-swift">let a = FeedbackAction.alert(title: "123", message: "abc")
let b = FeedbackAction.alert(title: "hello", message: "abc")
let c = FeedbackAction.alert(title: "123", message: "abc")
let d = FeedbackAction.toast(message: "abc")

a == b // false
a == c // true
a == d // false
</code></pre><p>So if your enum has associated values only from primitive types or types that have a built-in implementation of <code>Equatable</code>, you can just make the enum conform to the protocol and it will work like magic. Conversely, on a non-trivial custom type, you may have to implement <code>Equatable</code> conformance on this type, or give up and use the <code>switch</code> strategy.</p><h2>Thanks for reading!</h2><p>Liked this content? I always announce new articles on my <a href="https://twitter.com/oliveira__lucas">Twitter Account</a>. Suggestions, feedback, and corrections are always welcome.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/swift_ranges_cheat_sheet</guid><title>Swift ranges cheat sheet</title><description>Even after some years of experience in Swift, I still find ranges a little bit tricky and have to take a look in the docs or make a playground to test things out, before using them at work. This post is a cheat sheet with examples on how to use ranges.</description><link>https://lucas1295santos.github.io/posts/swift_ranges_cheat_sheet</link><pubDate>Wed, 3 Feb 2021 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Swift ranges cheat sheet</h1><p>Even after some years of experience in Swift, I still find ranges a little bit tricky and have to take a look in the docs or make a playground to test things out, before using them at work. This post is a cheat sheet with examples on how to use ranges.</p><h2>What is a range?</h2><p>A range comprises a collection of elements between a certain lower and upper bound, bounds which might be included or excluded. The simplest use case of ranges that you might have seen, is to iterate on a <code>for</code> loop.</p><pre><code class="language-swift">for _ in 0 ..&lt; 5 {
    print("Hello world") // prints Hello world 5 times
}
</code></pre><h2>Cheatsheet</h2><h3>Ranges to iterate</h3><p><code>...</code> is a closed range, meaning that it <strong>includes the upper and lower bound</strong>.</p><pre><code class="language-swift">for count in 0...3 {
    print(count) // prints 0 1 2 3
}
</code></pre><p><code>..&lt;</code> is a half-open range, meaning that it <strong>excludes the upper bound</strong> while <strong>includes the lower bound</strong></p><pre><code class="language-swift">for count in 0..&lt;3 {
    print(count)
}
</code></pre><p>So if you want to iterate through a full array, you probably want to use a half-open range.</p><pre><code class="language-swift">let arr = [1, 3, 5, 7, 9]
for index in 0..&lt;arr.count {
    print(arr[index]) // prints 1 3 5 7 9
}
</code></pre><p>Otherwise, you would crash the program with an index out of range exception.</p><pre><code class="language-swift">let arr = [1, 3, 5, 7, 9]
for index in 0...arr.count {
    print(arr[index]) // prints 1 3 5 7 9 and than CRASHES because it will try to access the index 5 which doesn't exists.
}
</code></pre><h3>Ranges to slice arrays</h3><p>It's easy to create <a href="https://developer.apple.com/documentation/swift/arrayslice">array slices</a> using ranges, as the same logic of iterations applies here. It is also super useful to use ranges in their unary operator version. Let's take a look at some ways to slice an array in half.</p><pre><code class="language-swift">let arr = [1, 3, 5, 7, 9]
let midpoint = arr.count / 2 // takes the middle index in this case 2, so arr[midpoint] would be 5 here.
let slice = arr[...midpoint] // creates an ArraySlice&lt;Int&gt; off the array from the first index (0) to the midpoint (2), including it.
for element in slice {
    print(element) // prints 1 3 5
}
</code></pre><p>If you don't want the midpoint you can just use the half-closed range <code>..&lt;</code> instead</p><pre><code class="language-swift">let arr = [1, 3, 5, 7, 9]
let midpoint = arr.count / 2 // takes the middle index in this case 2, so arr[midpoint] would be 5 here.
let slice = arr[..&lt;midpoint] // creates an ArraySlice&lt;Int&gt; off the array from the first index (0) to the midpoint (2), excluding it.
for element in slice {
    print(element) // prints 1 3
}
</code></pre><p>And if you want the right half of the array, you can use the closed range <code>...</code> postfixed.</p><pre><code class="language-swift">let arr = [1, 3, 5, 7, 9]
let midpoint = arr.count / 2 // takes the middle index in this case 2, so arr[midpoint] would be 5 here.
let slice = arr[midpoint...] // creates an ArraySlice&lt;Int&gt; off the array from the midpoint(2) to the end of the array (4).
for element in slice {
    print(element) // prints 5 7 9
}
</code></pre><p>Strangely, there is no half-closed range postfixed.</p><h3>Ranges in Enums</h3><p>It is not possible to directly associate ranges to Enum cases like this</p><pre><code class="language-swift">// This doesn't work
enum ScoreClassification {
    case awesome = 90...
    case good = 70..&lt;90
    case average = 40..&lt;70
    case bad = ..&lt;40
}
</code></pre><p>To work around that, you could make custom init on your enum and <code>switch</code> through the ranges.</p><pre><code class="language-swift">enum ScoreClassification {
    case awesome
    case good
    case average
    case bad
    
    init(score: Int) {
        switch score {
        case 90...:
            self = .average
        case 70..&lt;90:
            self = .good
        case 40..&lt;70:
            self = .average
        default:
            self = .bad
        }
    }
}

let scoreClassification = ScoreClassification(score: 87)
print(scoreClassification) // prints good
</code></pre><h2>Keep reading</h2><p>If you want more details and examples, you can always check the <a href="https://developer.apple.com/documentation/swift/range">Apple docs</a> for ranges, and <a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID73">Swift docs</a> for operators. Beyond official docs, <a href="https://www.avanderlee.com/swift/ranges-explained">SwiftLee</a> has great use examples.</p><p>And if you are in the vibes for learning more Swift related content you can check my <a href="https://www.lucasoliveira.tech/posts/quick-tip-2/">article about typealias</a>, where I explain what are type aliases in Swift, and how you could use them to improve code readability.</p><p>Thanks for reading all the way to the bottom of the page, hope you learned something new today! Until next time!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/quick-tip-2</guid><title>Quick tip #2: Typealias to improve readability</title><description>Swift's type-safety is one of the language's main features, and it is extremely powerful to harness the compiler type-check to your code. In this short article, I'll give some tips to improve readability and clearness of intent using some typing resources available.</description><link>https://lucas1295santos.github.io/posts/quick-tip-2</link><pubDate>Sun, 13 Dec 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Quick tip #2: Typealias to improve readability</h1><p>Swift's type-safety is one of the language's main features, and it is extremely powerful to harness the compiler type-check to your code. Meaning that making good use of protocols, protocol composition, default values, type-constraints, inheritance and, type aliasing, is important to guide a developer to use your classes, modules, or frameworks in the intended way, as the types constraints the data and its flow. In this short article, I'll give some tips to improve readability and clearness of intent using some typing resources available.</p><p>This article is in a way, an iteration on the last one about naming in software. You can read this one independently, but if you are interested in the subject, you can read it <a href="https://www.lucasoliveira.tech/posts/naming">here</a>. The article explains why naming is so important and gives some general advice on how to choose good names in software.</p><h2>Typealias</h2><p>In Swift, typaliases declarations introduce a new name to an existent type. The typealias access scope might be modified by the access modifiers <code>public</code>, <code>private</code>, and so on. You can read the official documentation <a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#grammar_typealias-declaration">here</a>.</p><p>Observe the example below. It shows how to use typealias in its simplest form, and is a nice and simple use case on how typealias can make code easy to understand.</p><pre><code class="language-swift">// Typealias declaration
typealias OrderUUID = String
// Typealias used on a function header
func appendOrder(with: OrderUUID)
// Function being used
appendOrder(with: "08129d15-2246-4157-ace9-5ad896d04764")
</code></pre><p>Typealiasing <code>String</code> as <code>OrderUUID</code> in this context makes the use of this function unambiguous, and we could even drop the label <code>with</code>. Keep in mind that making code as obvious as we can is our main goal here.</p><p>Although one could argue that this function is obvious even without the typealiasing, which is reasonable, most projects have some complex functions that receive many arguments, and in some cases, the complexity resides in the model. An <code>Order</code> object could have multiple identifier parameters like <code>uuid</code>, <code>number</code>, <code>analyticsID</code> and so on, so depending on the function context, you might be unsure on what is the identifier you should provide, so having the type <code>OrderUUID</code> regularly used on the project whenever this identifier is needed, could be the difference-maker.</p><p>Another useful use case of typealias is typing closures. The example below shows two functions that fetch and returns a page of items.</p><pre><code class="language-swift">typealias ItemPageCompletion = (Result&lt;ItemPage, Error&gt;) -&gt; Void

func fetchHighlightedItems(completion: @escaping ItemPageCompletion)
func fetchItemList(pageNumber: Int, completion: @escaping ItemPageCompletion)
</code></pre><p>Using the typealias <code>ItemPageCompletion</code> to substitute <code>Result&lt;ItemPage, Error&gt; -&gt; Void</code> makes function declaration compact without losing meaning. It also makes it easier to glance over the two functions and perceive that both deal with the same type of data.</p><p>Last but not least, <code>TimeInterval</code> from <code>Foundation</code> is a very good example of how type aliases can be effective.</p><pre><code class="language-swift">// From Foundation.NSDate
public typealias TimeInterval = Double
// An example of foundation that uses TimeInterval 
extension NSDate {
    open func addingTimeInterval(_ ti: TimeInterval) -&gt; Self
}
</code></pre><p>Since <code>Double</code> is a really broad type that can be used for an infinity of contexts and can mean roughly anything, when dealing with time intervals, Apple's APIs uses only <code>TimeInterval</code>. This way the developers that are interacting with the API are not in doubt if the number that they have to provide is the timestamp of some date or an interval. Think of how ambiguous it would be if the function from the example above were written like the following:</p><pre><code class="language-swift">extension NSDate {
    open func adding(_ ti: Double) -&gt; Self
}
</code></pre><p>And the coolest thing about the <code>TimeInterval</code> example is how it is possible to add documentation to the type if more information is needed.</p><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post_quicktip2_img1.png" alt="TimeInterval documentation" style="width:480px;"/><p>You could create documentation for your own type aliases the same way you would create for a class or function. If you are new to documentation on XCode, <a href="https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html#//apple_ref/doc/uid/TP40016497-CH2-SW1">this guide</a> has everything you have to know (plus some cool formatting tips for playgrounds).</p><pre><code class="language-swift">/// The UUID of an Order, found in the parameter UUID from Order
typealias OrderUUID = String
</code></pre><h2>Thanks for reading!</h2><p>Liked this content? I always announce new articles on my <a href="https://twitter.com/oliveira__lucas">Twitter Account</a>. Suggestions, feedback, and corrections are always welcome.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/naming</guid><title>Naming and code quality</title><description>Naming is one of the most underrated and overlooked skills that a good programmer should have, yet is a skill that we use every day by giving names to variables, functions, services, and so on. Good names make messy code easier to understand, and makes good code a delight to read. In this post, I'll share some insights on how to detect bad naming, and how to improve it.</description><link>https://lucas1295santos.github.io/posts/naming</link><pubDate>Sat, 14 Nov 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Naming and code quality</h1><p>Naming is one of the most underrated and overlooked skills that a good programmer should have, yet is a skill that we use every day by giving names to variables, functions, services, and so on. Good names make messy code easier to understand, and makes good code a delight to read. In this post, I'll share some insights on how to detect bad naming, and how to improve it.</p><p>During my years at the academy studying software engineering I invested a lot of time and effort in problem-solving skills, thinking about the Object-Oriented modeling, the data structures that would be employed, the efficiency of the algorithms, and the data types on each variable. And it was time really well spent, those decisions are really important and complex, so to get it right, you should practice a lot. But during all that time, I never had a professor saying to me that I should think about the names I'd use in my code. Maybe that's because when you are an undergraduate, the code you write is not meant to last. Once the assignment is done, you'll never see it again.</p><p>When you code professionally, most of the time you'll extend and modify code that other people wrote, and the code that you write is going to be extended and modified by other people. Furthermore, your code is meant to last because you are creating a valuable asset to the company. This is the turning point where you have to understand that the code you write is for both humans and machines.</p><p>In the industry, code that successfully compiles and attend to the requisites is not enough, the code needs to be readable. Unreadable code is objectively worst, because in the future a developer will spend a lot of time understanding the unreadable code before even beginning to modify it, and that means developer time and effort being wasted.</p><p>Last, think about all the times you were in the situation of having to jump headfirst on a messy code to solve some problem, it is never a pleasant experience. As developers, we are the ones to blame when code gets that bad, and we are the ones that can improve it.</p><h1>Signs of bad naming</h1><p>A few Saturdays ago I was on a software engineering lecture implementing a <a href="https://en.wikipedia.org/wiki/Josephus_problem">Josephus Problem</a> empirical algorithm along with the professor, and I and my classmates were having a hard time understanding the rationale behind the implementation, and to explain that, followed a long and confusing discussion about the strategy behind the implementation in terms of variables like <code>n</code> <code>k</code> and <code>curVal</code>. Meanwhile, I was wondering how much shorter the discussion would be if the variables were named after what they represented.</p><p>Next, we'll take a look at how good naming would make the Josephus Problem implementation way easier to understand. If you already know the problem, just skip to the implementation, if not, I'll give a brief explanation.</p><h3>Josephus Problem explanation</h3><p>Captured soldiers are put on a circle to be executed. The executioner will pick a number and will start counting the captured soldiers around the circle in a specific direction. When he gets to the selected number, the soldier being counted gets executed. The process will repeat until there is only one soldier left in the circle, this last soldier gets freed. For a more in-depth study on the problem, go to <a href="https://www.geogebra.org/m/ExvvrBbR">GeoGebra</a>, they even have a didactic video and simulation of it.</p><h3>Josephus Problem implementation</h3><p>The following implementation written in Java was the empirical implementation provided by the professor.</p><pre><code class="language-swift">class JosephusProblem {
    var n: Int
    var k: Int
    var circle: [Bool] = []
    var alive: Int = 0
    var curVal: Int = 0

    init(n: Int, k: Int) {
        self.n = n
        self.k = k
        start()
    }

    func start() -&gt; Int {
        circle = []
        for _ in 0 ..&lt; n {
            circle.append(true)
        }
        alive = n
        curVal = 0
        return curVal
    }

    func next() -&gt; Int {
        if (alive == 0) {
            return -1
        }
        for _ in 0 ..&lt; k {
            repeat {
                curVal = (curVal + 1) % n
            } while (!circle[curVal])
        }
        circle[curVal] = false
        alive -= 1
        return curVal
    }

    func print(n: Int) -&gt; String {
        var progression = ""
        for _ in 0 ..&lt; n {
            progression.append(" ")
            progression.append(String(next()))
        }
        return progression
    }
}
</code></pre><p>Executing the function <code>print</code> after inciating with parameters <code>JosephusProblem(8, 2)</code> would display the output:</p><pre><code> 2 4 6 0 3 7 5 1
</code></pre><p>Meaning that the soldiers would be executed starting by the one at position 2, in that order, until the one at position 1 is freed.</p><p>Was it easy to understand how the code above implements a possible solution to the problem? The first time I read it, it wasn't easy. To help myself understand, I renamed all the variables and functions like this:</p><pre><code class="language-swift">class JosephusProblem {
    var numberOfSoldiers: Int
    var countingConstant: Int
    var soldierStatus: [SoldierStatus] = []
    var numberOfSoldiersAlive: Int = 0
    var currentSoldierPosition: Int = 0

    init(numberOfSoldiers: Int, countingConstant: Int) {
        self.numberOfSoldiers = numberOfSoldiers
        self.countingConstant = countingConstant
        setUp()
    }

    func setUp() -&gt; Int {
        soldierStatus = []
        for _ in 0 ..&lt; numberOfSoldiers {
            soldierStatus.append(.alive)
        }
        numberOfSoldiersAlive = numberOfSoldiers
        currentSoldierPosition = 0
        return currentSoldierPosition
    }

    func getNextExecutedSoldierPosition() -&gt; Int {
        if (numberOfSoldiersAlive == 0) {
            return -1
        }
        for _ in 0 ..&lt; countingConstant {
            repeat {
                currentSoldierPosition = (currentSoldierPosition + 1) % numberOfSoldiers
            } while (soldierStatus[currentSoldierPosition] == .dead)
        }
        soldierStatus[currentSoldierPosition] = .dead
        numberOfSoldiersAlive -= 1
        return currentSoldierPosition
    }

    func getNextExecutions(numberOfExecutions: Int) -&gt; String {
        var executions = ""
        for _ in 0 ..&lt; numberOfExecutions {
            executions.append(" ")
            executions.append(String(getNextExecutedSoldierPosition()))
        }
        return executions
    }
}

enum SoldierStatus {
    case dead
    case alive
}
</code></pre><p>Notice how easier the code got only by renaming variables and functions. No logic was modified and yet some complexity vanished. Let's go through the major renames that got the code easier to understand.</p><h3>Use contextual names</h3><p>Renaming <code>n</code> to <code>numberOfSoldiers</code> and <code>k</code> to <code>countingConstant</code> and <code>curVal</code> to <code>currentSoldierPosition</code> added context to the algorithm, and that is super valuable as it makes the code intuitive.</p><pre><code class="language-swift">// Consider the code bellow that is part of the class initialization
// Before naming refactor
circle = []
for _ in 0 ..&lt; n {
    circle.append(true)
}
// After naming refactor
soldierStatus = []
for _ in 0 ..&lt; numberOfSoldiers {
    soldierStatus.append(.alive)
}
</code></pre><p>Reading this expression before the refactor you may need to go further in inspecting the code to check what is <code>n</code>, and to understand what are the boolean values on <code>circle</code> so we can know what does it mean to have a <code>circle</code> full of <em>true</em> values.</p><p>After the refactor the code kind of explains itself. And that's beautiful!</p><h3>Use enums to give even more context</h3><p>Enums are one of the most powerful features in Swift, and they are awesome to improve code clarity and readability because you can name each case according to a state from the application using problem domain-specific language.</p><pre><code class="language-swift">// Before refactor
while (!circle[curVal])
// After refactor
while (soldierStatus[currentSoldierPosition] == .dead)
</code></pre><h1>Good practices in naming</h1><p>Now that you got a pretty good idea on why naming matters, the next natural question is: "how would I choose good names?" - I'll show you a handful of good practices and principles to choose good names, but mostly you'll have to figure it out case by case. But if you ever find yourself in doubt, you can always figure if your naming is bad by showing your code to peers.</p><p>Remember that you are writing code that other humans will read, reuse, extend, modify or, even delete. So always aim for following these general rules:</p><ul><li>Intent revealing: your code should make explicit what it does.</li><li>Accurate: choosing names that imply that the code does something that it doesn't is the same as setting up a trap.</li><li>Consistent: consistent names make it easier to find patterns and deduce behavior. If you have three functions that just return a value, don't call them <code>getX</code>, <code>retrieveY</code>, and <code>fetchZ</code>. People will assume that they do three different things, so choose a pattern and stick with it.</li></ul><h3>Conform to language/framework standards</h3><p>You are sharing the codebase with fellow developers that are used to the project's language and framework standards, being from reading docs, open-source projects, or previous work experience. Conforming to those standards allows the developers to benefit from this experience to accelerate their understanding of the code.</p><p>Usually, it is easy to find the language standards documents. You can read Swift's naming standards on the <a href="https://swift.org/documentation/api-design-guidelines/#naming">Swift API guidelines</a>.</p><h3>Don't abbreviate</h3><p>Abbreviations might seem obvious to whoever created it, or to the team that is immersed in the context of the code, but for a new-comer or an outsider, abbreviated names may mean nothing. Furthermore, by abbreviating you are not even gaining much, because we all work with IDEs with auto-completion enabled, so if the name of your class is long, you'll probably just type the first 4 letters and auto-complete the rest of it. The only exception is when you are naming after broadly known abbreviations like <code>UI</code>. It is safe to assume that any mobile or web developer knows what a <code>UI</code> is.</p><h3>Use verbs for functions</h3><p>Functions are encapsulated actions that your program can perform, so by definition, you should name them as verbs. By doing this, you are improving readability by making the code syntax feel more natural.</p><pre><code class="language-swift">func fetchOrder(by: , completion: )
func setupLayout()
func dequeue() -&gt; Value?
</code></pre><h3>Name the design patterns you use</h3><p>If you are using the delegate pattern to solve the communication between a payments view and its controller, don't try to reinvent the wheel, and simply name the protocol as <code>PaymentsViewDelegate</code>. The next developer who reads this code, probably knows what a delegate is and how it works, and just like this, he can skip reading the full implementation, because he already has a pretty good idea on where to go next. Conversely, if the implementation feels like a design pattern, but is not, do not name it after the design pattern, else you are setting up a trap for someone else in the future.</p><h3>Show your code to peers</h3><p>Sometimes it is really hard to choose a good name, and showing the code to someone that is not as immersed and biased on the subject as you are, might help a lot. Even the simple exercise of reading the code out loud will make bad naming clearer.</p><p>A great way of sharing the code with peers is by reading the code out loud and explaining how it works, the effort of contextualizing the problem and explaining the solution bit by bit may give you good insights. Pair programming also helps a lot, as often developers disagree with naming choices, leading to a rich discussion. And my favorite method is doing a pair code review, where you open a draft pull request and review the code along with one or more teammates, there are always lots of insights and suggestions of improvement.</p><h3>Go beyond this article</h3><p>Here are some great resources that helped me be better at naming in software, and were inspirations for this article:</p><ul><li>Good motivation on why you should care about naming, and its general principles by Gergely Orosz from the Pragmatic Engineer. <a href="https://blog.pragmaticengineer.com/readable-code">Read the post!</a></li><li>The section <em>Naming Things</em> from chapter 7 of <em>The Pragmatic Programmer</em> provides good examples, and questions that you should be doing while renaming code. <a href="https://ler.amazon.com.br/kp/embed?asin=B07VRS84D1&preview=newtab&linkCode=kpe&ref_=cm_sw_r_kb_dp_W89RFbA9SYG0F">Buy it on Amazon!</a></li><li>Chapter 2 <em>Meaningful names</em> from <em>Clean Code</em> is also a great reference, and was the chapter that made me realize the importance of taking the time and effort to name software. <a href="https://ler.amazon.com.br/kp/embed?asin=B001GSTOAM&preview=newtab&linkCode=kpe&ref_=cm_sw_r_kb_dp_cf-RFbNB5S5HN">Buy it on Amazon!</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/test-doubles</guid><title>Writing good tests with Tests Doubles</title><description>Writing unit tests is one of the key responsibilities of a developer. Although writing a test is not that hard, setting up a controlled environment where you can unit test one component might be challenging, especially if your component is surrounded by legacy code. Setting up testing doubles is a winner technique to tackle this problem.</description><link>https://lucas1295santos.github.io/posts/test-doubles</link><pubDate>Thu, 1 Oct 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Writing good tests with Tests Doubles</h1><p>Writing unit tests is one of the key responsibilities of a developer. Although writing a test is not that hard, setting up a controlled environment where you can unit test one component might be challenging, especially if your component is surrounded by legacy code. Setting up testing doubles is a winner technique to tackle this problem.</p><p>If you are starting out on unit tests, you may already face issues like testing passing on your machine, and failing on your teammate's, or tests randomly failing without you making any changes related to the tests. And if you never faced issues like that, eventually, you will. Frequently those problems are due to the component that you are testing directly or indirectly depending on a resource that might change over executions, like responses from network requests, DataBase state, UserDefaults state, or even variables of a singleton.</p><p>Let's take a look at this example:</p><pre><code class="language-swift">// This label is part of my ViewController. If the user already registered its name, this label
// should greet by the name, else, it will greet the user as Guest.
class ViewController: UIViewController {
    var greetingsLabel = UILabel()

    func configure() {
        let userName = UserData().getUserName() ?? "Guest"
        greetingsLabel.text = "Hello, \(userName)!"
    }
    /*
        More code here...
    */
}

// And this is our UserData class, it saves and gets the user name from UserDefaults.

class UserData {
    func saveUserName(name: String) {
        UserDefaults.standard.setValue(name, forKey: "USER_NAME")
    }
    
    func getUserName() -&gt; String? {
        UserDefaults.standard.string(forKey: "USER_NAME")
    }
}

// Now we will unit test the logic of our ViewController

class ViewControllerTests: XCTestCase {
    func test_greetingsLabel_beforeSettingName_expectNameToBeGuest() {
        let sut = ViewController()
        
        sut.configure()

        XCTAssertEqual(sut.greetingsLabel.text, "Hello, Guest!")
    }
    
    func test_greetingsLabel_afterSettingName_expectNameToEqualsUserName() {
        let sut = ViewController()
        UserData().saveUserName(name: "John")

        sut.configure()
        
        XCTAssertEqual(sut.greetingsLabel.text, "Hello, John!")
    }
}
</code></pre><p>After writing this code, you can test them on the simulator, and it will work fine. You can run the tests, and they will pass, as they should. After asserting that the code works, you start working on your next feature, and when you execute the tests you will be taken by surprise as the test <code>test_greetingsLabel_beforeSettingName_expectNameToBeGuest</code> will fail, even if you didn't do any change to the label <code>greetingsLabel</code> on the <code>ViewController</code> or the data class <code>UserData</code>.</p><p>The test fails because the second time you execute this test, the simulator that you run your tests on has already saved the value "John" for the key <code>USER_NAME</code> on UserDefaults. This value is set on the second test (<code>test_greetingsLabel_afterSettingName_expectNameToEqualsUserName</code>). So instead of setting the text to "Hello, Guest!", it will set to "Hello, John!", therefore failing the test.</p><h2>What is a Test Double</h2><p>In the movies, a stunt double is a professional that replaces the actor on interpreting a character in scenes of risky stunts, or highly demanding athletic skills. The stunt double should be similar enough to the actor to convince the audience and convey the idea that the character is doing the stunts in the movie. The idea of a test double is really similar: a test double is a class that replaces the desired class during tests.</p><p>Think about the example we just saw, where the tests failed after executing two times. A really nice way to solve our problem would be to somehow use the class <code>UserData</code> just on our app's "production" code, but when testing we would use a class just like <code>UserData</code>, but instead of getting information on UserDefaults, it could return whatever we want. So when testing the ViewController's label, we could set this class to return John, and assert that the text of the label is "Hello, John!", and on the next text set it to return nil, and assert that text is "Hello, Guest!". This way our test would not depend on UserDefaults and would be consistent for sure.</p><p>This is the concept of a test double, and the main way to achieve that is by creating a protocol that defines the methods that a <code>UserData</code> class should have.</p><pre><code class="language-swift">protocol UserDataProtocol {
    func saveUserName(name: String)
    func getUserName() -&gt; String?
}

// After creating the protocol, we make UserData conform to that protocol

class UserData: UserDataProtocol {
    func saveUserName(name: String) {
        UserDefaults.standard.setValue(name, forKey: "USER_NAME")
    }
    
    func getUserName() -&gt; String? {
        UserDefaults.standard.string(forKey: "USER_NAME")
    }
}

// And we create the test double of UserData

class UserDataMock: UserDataProtocol {
    func saveUserName(name: String) {}
    
    var userNameToBeReturned: String?
    func getUserName() -&gt; String? {
        return userNameToBeReturned
    }
}
</code></pre><p>Notice how we created a variable <code>userNameToBeReturned</code> to give us total control of what the method <code>getUserName</code> returns, and it does not depends on UserDefaults. The next step to solve the test problem is to make it possible to use <code>UserData</code> when running the app, and <code>UserDataMock</code> when testing.</p><h2>Dependency Inversion Principle</h2><p>The Dependency Inversion Principle (<code>DIP</code>) is part of the <code>SOLID</code> set of good practices for Object-Oriented Design. The main idea of this principle is that your objects should depend on abstractions and not concrete implementations. And as in our last example, protocols are a good way of creating abstractions.</p><p>Depending on abstractions gives you a lot of flexibility to change the implementation of a component without propagating changes to its neighbors (the components that interact with it). And also the abstractions will help us to improve testability, as we can easily slip in a test double to replace a dependency at testing time.</p><p>Let's take a look at how we could make our <code>ViewController</code> stop depending on <code>UserData</code> and depending on the abstraction <code>UserDataProtocol</code> instead.</p><pre><code class="language-swift">class ViewController: UIViewController {
    var greetingsLabel = UILabel()
    // Holding an instance of an object that implements UserDataProtocol
    let userData: UserDataProtocol
    
    // We set the default value of userData as a new instance of a UserData object by default
    // Doing it this way, it is important to remember to init this class passing a new instance
    // of UserDataMock when testing
    init(userData: UserDataProtocol = UserData()) {
        self.userData = userData
        super.init(nibName: nil, bundle: nil)
    }
    
    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func configure() {
        // Now instead of creating a UserData instance, and using it. We will use the 
        // instance provided at init time, that could be the real UserData, or the
        // test double UserDataMock.
        let userName = userData.getUserName() ?? "Guest"
        greetingsLabel.text = "Hello, \(userName)!"
    }
}
</code></pre><p>Now that the <code>ViewController</code> is set up, let's rewrite the <code>ViewControllerTests</code> using test doubles to have a reliable test.</p><pre><code class="language-swift">    func test_greetingsLabel_userNameIsNil_expectNameToBeGuest() {
        let userData = UserDataMock()
        // sets up UserDataMock to return nil when getUserName is called
        userData.userNameToBeReturned = nil
        // makes the ViewController use the test double
        let sut = ViewController(userData: userData)
        
        sut.configure()
        
        XCTAssertEqual(sut.greetingsLabel.text, "Hello, Guest!")
    }
    
    func test_greetingsLabel_userNameIsNotNil_expectNameToEqualsUserName() {
        let userData = UserDataMock()
        // sets up UserDataMock to return John when getUserName is called
        userData.userNameToBeReturned = "John"
        let sut = ViewController(userData: userData)
        
        sut.configure()
         
        XCTAssertEqual(sut.greetingsLabel.text, "Hello, John!")
    }
</code></pre><p>Finally, the <code>ViewControllerTest</code> is reliable, as the logic of <code>greetingsLabel</code> is isolated, and it does not depend on any external component.</p><h2>Final thoughts</h2><p>To master the usage of test doubles, you have to master writing testable code, which requires a lot of practice writing code with bad testability and than improving it.</p><p>One thing to keep in mind is that you always have to decide which dependencies of your class can be decoupled from it, meaning that if the dependency change implementation, the class can continue working without changing as well. So on the class's tests, you can use test doubles to substitute every decoupled dependency, and test the class in a reliable and consistent environment, where you can easily test any scenario in a way that the tests will only fail if internal logic changes.</p><h2>What's next?</h2><p>If you want to know more about <code>DIP</code> and the other <code>SOLID</code> principles, <a href="https://hackernoon.com/solid-principles-made-easy-67b1246bcdf">this article from hackernoon</a> is a great light start. And <a href="https://github.com/ochococo/OOD-Principles-In-Swift">This repo from ochococo</a> gives nice and easy examples and has links to in-depth articles that are really good reading.</p><p>If you want to know how to unit test asynchronous code, check out <a href="https://www.lucasoliveira.tech/posts/async-tests">my article about it</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/improving-error-handling-in-your-app</guid><title>Improving Error Handling in your App in Swift.</title><description>We want our software to be error-proof, but in reality, error scenarios will always exist.&lt;br&gt;&lt;/br&gt;So this article's objective is to explain why you should handle errors on your app, give you a rule of thumb on when treating errors, and give some practical improvements you could apply on your app.</description><link>https://lucas1295santos.github.io/posts/improving-error-handling-in-your-app</link><pubDate>Tue, 4 Aug 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Improving Error Handling in your App in Swift.</h1><p>We want our software to be error-proof, but in reality, error scenarios will always exist.</p><p>So this article's objective is to explain why you should handle errors on your app, give you a rule of thumb on when treating errors, and give some practical improvements you could apply on your app.</p><h2>Why handling errors?</h2><h3>Finding errors <em>asap</em></h3><p>Worse than finding a bug on your production app is learning that the bug you just found is around for several releases.</p><p>Below is the recipe of failure to ship a hard to catch bug.</p><pre><code class="language-swift">func callMerchant(with telefoneNumber: String?) {
    guard let phone = telefoneNumber else { return }
    // Calling a phone number code goes here
}
</code></pre><p>If for some reason this function is ever invoked with a <code>nil</code> telefoneNumber, it will exit without trying to make the phone call, and this could lead to a useless call button on your user interface, that does nothing when pressed.</p><h3>Improving User Experience (UX)</h3><p>It might be really frightening to a user with no technology background to be prompted with an error dialog full of tech words and error codes, especially if he just made a critical action like a purchase. Take a look at the picture on the left.</p><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post4_img1.png" alt="Error notification" style="width:500px;"/><p>On the other hand, the picture to the right explains what happened and how the user could proceed.</p><h3>Recovering from an error state to a success</h3><p>With a really well-crafted error recovering strategy you could even recover a user that got in an error state, to the main flow of your application that will lead to a goal (like making a purchase).</p><p>Recovering from errors is not only important for the tech team, but it is also beneficial for the business as a whole. Commonly, digital products lose some conversion percentual points due to techinical issues. And good error handling might mitigate this issue.</p><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post4_image2.png" alt="Error state recovery" style="width:500px;"/><p>The example above gives clear instructions and even some shortcuts on how to get out of this error and try another product.</p><h2>Rule of thumb to handling errors</h2><p>Maybe your App is nothing like any of the examples I gave so far, and you are not sure where you could improve error handling in your app. So you could follow this rule of thumb to know where you should consider handling errors.</p><p>Consider handling errors every time you...</p><ul><li>...make a request to an external source (networking)</li><li>...capture user input</li><li>...encode or decode some data</li><li>...escape a function prior to its full execution (early return)</li></ul><h2>Practical improvements for your App</h2><h3>Monitoring tool</h3><p>This is the most important improvement that you could do! With a monitoring tool, you can have useful data to discover, understand, and prioritize errors.</p><p>By understanding the volumetry of an error, you could decide between adding a fix to the next version, creating a new version as soon as possible just to fix that error (hotfix), or turn off some remote configuration to disable the problematic feature.</p><p>There are several monitoring tools available on the market, like <a href="https://www.dynatrace.com/">Dynatrace</a> or <a href="https://newrelic.com/">New Relic</a>. The monitoring tool that I use at iFood is <a href="https://logz.io/">Logz.io</a>. It provides all the utility that we need to keep track of error logs:</p><ul><li>Logs over time</li><li>Querying for specific logs</li><li>Configuring alerts to send to Slack</li><li>Dashboard creation</li></ul><p>With a good tool setup in the project, it is time to bring a monitoring culture to the team. You could start establishing some new tasks that should be done at every new feature development.</p><ul><li>Map all error cases</li><li>Create logs for the error cases</li><li>Create alerts for the logs to get any critical scenario. It is important that the alerts are sent to a channel where all the devs have access.</li><li>Create a Dashboard containing all the logs for that feature</li><li>Monitor the dashboard periodically. You could make a recurrent event on the calendar to be reminded.</li></ul><h3>Swift's Error protocol</h3><p>Swift's error protocol allows you to create expressive errors that will give you useful information to find and act on a possible issue. Having rich errors will also help you to create insightful dashboards and precise alerts on your monitoring tool.</p><p>Below, there is a simple example of how to use it in an enumerator.</p><pre><code class="language-swift">enum SimpleError: Error {
    case generic
    case network(payload: [String: Any])
}
</code></pre><p>In this example, we will capture the payload of the request that caused a network error. Doing so, we could look for patterns on the payloads, and understand what really causes the error.</p><p><strong>Disclaimer:</strong> if you want to do an error treatment like that one where you send the payload from a network request, you must mask any user sensitive data.</p><p>You could also conform to this protocol in a <code>struct</code> so you can have as much information as you need on the error. This is useful when you want to custom tailor an error for a very specific scenario.</p><pre><code class="language-swift">struct StructError: Error {
    enum ErrorType {
        case one
        case two
    }
    let line: Int
    let file: String
    let type: ErrorType
    let isUserLoggedIn: Bool
}
// ...
func functionThatThrowsError throws {
    throw StructError(line: 53, file: "main.swift", type: .one, isUserLoggedIn: false)
}
</code></pre><p>Later on your monitoring tool, you could create a dashboard comparing the volumetry when the user has logged in again when it is not logged in, so you can understand if this is a relevant factor that leads to the error.</p><p>And if you want the error to also contain localized human-readable messages to display, you could also conform to <code>LocalizedError</code> as shown below.</p><pre><code class="language-swift">enum RegisterUserError: Error {
    case emptyName
    case invalidEmail
    case invalidPassword
}

extension RegisterUserError: LocalizedError {
    // errorDescription is the one that you get when using error.localizedDescription
    var errorDescription: String? {
        switch self {
        case .emptyName:
            return "Name can't be empty"
        case .invalidEmail:
            return "Invalid email format"
        case .invalidPassword:
            return "The password must be at least 8 characters long"
        }
    }
}
</code></pre><p>Now if an error of type <code>RegisterUserError</code> happens, you could display <code>error.localizedDescription</code> to the user.</p><h3>Don't use <code>nil</code> as an error</h3><p>Take a look at the function below, it is uncanny how familiar this code is.</p><pre><code class="language-swift">func getUserPreferences() -&gt; UserPreferences? {
    let dataFromKey = UserDefaults.standard.data.(forKey: "user_preferences")
    guard let data = dataFromKey else { return nil }
    let decoder = JSONDecoder()
    let userPreferences = try? decoder.decode(UserPreferences.self, from: data)
    return userPreferences
}
</code></pre><p>At first glance, pretty standard implementation. Nothing wrong with that. But if this code ever returns <code>nil</code>, how would you know if there are no <code>UserPreferences</code> set yet or if there is something wrong with our encoding or decoding of this object?</p><p>If we want to ship this code to production it would be really nice that the caller of this function would create and save a new <code>UserPreferences</code> with default preferences if there are none set, or log an error to our monitoring tool if the decoding failed, so we could investigate and fix it.</p><p>Returning <code>nil</code> when some error occurs really limits the options you have to handle it.</p><p>You could instead make the function throwable, declaring it with <code>throws</code> and removing the optional mark <code>?</code> from the decoder's <code>try</code>. If you never used <code>throws</code> in Swift, I strongly recommend you read this <a href="https://www.swiftbysundell.com/basics/error-handling">article from Sundell</a> and the <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html">Swift docs</a>, as I'll not cover the basics on what it is and how it works.</p><pre><code class="language-swift">func getUserPreferences() throws -&gt; UserPreferences {
    let dataFromKey = UserDefaults.standard.data.(forKey: "user_preferences")
    guard let data = dataFromKey else {
        throw UserPreferencesError.noUserPreferences
    }
    let decoder = JSONDecoder()
    let userPreferences = try decoder.decode(UserPreferences.self, from: data)
    return userPreferences
}
</code></pre><p><strong>Note: </strong> on the example above, it would be correct to return <code>nil</code> on the <code>else</code> clause of the <code>guard</code>, as <code>nil</code> is in fact the representation of the absence of value. I went all-in on throws just to illustrate better how it could be used.</p><p>But what if the errors happen in an asynchronous context? Is it time to return <code>nil</code>? Still, not ideal, instead, we could use other Swift's nice feature for error handling that suits really well in asynchronous contexts: <code>Result</code>.</p><p><code>Result</code> is an <code>enum</code> with the form <code>Result&lt;Success, Failure&gt; where Failure: Error</code> that has a <code>success</code> case with the result of the request as an associated value, and a <code>failure</code> case that brings an <code>Error</code> associated. Again, if you never heard of <code>Result</code> before, I strongly recommend this quick read from <a href="https://www.hackingwithswift.com/articles/161/how-to-use-result-in-swift#:~:text=Swift's%20Result%20type%20is%20implemented,conforms%20to%20Swift's%20Error%20type.&text=Even%20in%20this%20simple%20scenario%2C%20Result%20has%20provided%20two%20benefits.">hacking with swift</a>.</p><p>If our <code>getUserPreferences</code> fetch its data from a server instead of <code>UserDefaults</code>, we could rewrite it like the example below.</p><pre><code class="language-swift">func getUserPreferences(userID id: String, completion: @escaping (Result&lt;UserPreferences, Error&gt;) -&gt; Void) {
    Network.request(.userPreferences(userID: id)) { result in
      switch result {
      case .success(let data):
          do {
              let decoder = JSONDecoder()
              let userPreferences = try decoder.decode(UserPreferences.self, from: data)
              completion(.sucess(userPreferences))
          } catch {
              completion(.failure(error))
          }
      case .failure(let error):
          completion(.failure(error))
      }
    }
}
</code></pre><p>This way, the caller function could differentiate an encoding error from a network error, and log it.</p><h3>Separate error handling from the actual functionality</h3><p>If you are familiar with the <code>SOLID</code> principles, you know the importance of the <em>Single Responsibility Principle (SRP)</em>. The <em>SRP</em> says that our software units should have a single responsibility. What is a responsibility depends on the size of the software unit, the responsibility that a function can have is more narrow than the responsibility that a class or a module could handle.</p><p>Take a look on the example below:</p><pre><code class="language-swift">func registerUser(_ user: User) throws {
    guard user.name.isEmpty == false else {
        throw RegisterUserError.emptyName
    }
    guard isValid(email: user.email) else {
        throw RegisterUserError.invalidEmail
    }
    guard isValid(password: user.password) else {
        throw RegisterUserError.invalidPassword
    }
    /*
        Code that registers a user goes here
    */
}
</code></pre><p>The function <code>registerUser</code> breaks <em>SRP</em> and it is not easy to read because the code that actually register the user is at the end of the function, with all the validation rules first.</p><p>We could greatly improve this function by separating the error handling responsibility from the user registering responsibility.</p><pre><code class="language-swift">func registerUser(_ user: User) throws {
    try validateUser(user)
    /*
        Code that registers a user goes here
    */
}

func validateUser(_ user: User) throws {
    guard user.name.isEmpty == false else {
        throw RegisterUserError.emptyName
    }
    guard isValid(email: user.email) else {
        throw RegisterUserError.invalidEmail
    }
    guard isValid(password: user.password) else {
        throw RegisterUserError.invalidPassword
    }
}
</code></pre><p>Conforming to the <em>SRP</em> made this function that much easier to read.</p><h2>Recap</h2><ul><li> Don't leave errors unhandled, your users will appreciate it.</li><li> Use a monitoring tool on your project.</li><li> Use Swift's <code>Error</code> protocol to get expressive and useful errors.</li><li> Don't use <code>nil</code> as an error.</li><li> Separate error validation and treatment from the actual functionality.</li></ul><h2>What's next?</h2><p>If you are interested in error handling, chapter 6 of <em>Clean Code from Robert C. Martin (a.k.a Uncle Bob)</em> is a must-read. This chapter was the biggest reference to this article, and it was what really drew my attention to the importance of handling errors. I consider this book a must-have for any software engineer, so you might as well <a href="https://www.amazon.com.br/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">get it on Amazon</a>.</p><p>If you want to know more about <code>SRP</code> and the other <code>SOLID</code> principles, <a href="https://hackernoon.com/solid-principles-made-easy-67b1246bcdf">this article from hackernoon</a> is a great light start. And <a href="https://github.com/ochococo/OOD-Principles-In-Swift">This repo from ochococo</a> gives nice and easy examples and has links to in-depth articles that are really good reading.</p><p>Thank you for reading! I hope this is was insightful and that you can apply those ideas on your projects. Take care and good error handling!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/async-tests</guid><title>Testing asynchronous code</title><description>When you are starting out on testing your code, you might find asynchronous methods a little bit tricky to test. &lt;br&gt;&lt;/br&gt; But do not worry, *XCTestExpectation* got you covered if you want to assert that an async block *will* execute, or even assert that it *will not* execute.</description><link>https://lucas1295santos.github.io/posts/async-tests</link><pubDate>Tue, 7 Jul 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Testing asynchronous code</h1><p>When you are starting out on testing your code, you might find asynchronous methods a little bit tricky to test.</p><p>But do not worry, <code>XCTestExpectation</code> got you covered if you want to assert that an async block <strong>will</strong> execute, or even assert that it <strong>will not</strong> execute.</p><p>In this post, I'll show you a really common case where you'll want to test an asynchronous method, and how to use <code>XCTestExpectation</code> to create an expectation that a block will be executed on the future, and how to create an inverted expectation to assert that a block will not be executed on the future.</p><h2>The use case</h2><p>Let's say that you are creating a feature that displays information about an item that your app sells. This feature will download the item details from an endpoint on a server whenever the user selects an item from a list. Then you will get the item ID and make an HTTP request to this endpoint to retrieve the item details. But to be more efficient on data usage, you also should cache every item fetched, so if the user wants to see details of an item that was already cached, instead of fetching it from the endpoint, you'll return the cached item.</p><p>To achieve this goal, this feature will have an <code>ItemWorker</code> class. It's objective is to return an item, given an ID. This class will contain the mechanism to get the item from a cache through a <code>CacheRepository</code> or, request it to the endpoint using <code>Network</code>.</p><p>This is a possible implementation of this class:</p><pre><code class="language-swift">final class ItemWorker {
    private let network: NetworkProtocol
    private let cache: CacheRepositoryProtocol
    
    init(
        network: NetworkProtocol = Network.shared,
        cache: CacheRepositoryProtocol = CacheRepository.shared
    ) {
        self.network = network
        self.cache = cache
    }
    
    func requestItem(withID id: String, completion: @escaping (Result&lt;Item, Error&gt;) -&gt; Void) {
        // If the cache contains the item, return the item
        if let cachedItem: Item = cache.get(forKey: id) {
            completion(.success(cachedItem))
        } else {
            let request = ItemRequest.itemByID(id: id)
            // Request an item passing the ID
            network.request(request) { [weak self] (result: Result&lt;Item, Error&gt;) in
                if case let Result.success(item) = result {
                    // Cache the item if succeded
                    self?.cache.set(item: item, forKey: item.id)
                }
                // Return what was fetched
                completion(result)
            }
        }
    }
}
</code></pre><p>Notice on this example that <code>Network</code> and <code>CacheRepository</code> are <strong>singletons</strong>, but however, I didn't use their shared instance directly. I used a <strong>Dependency injection</strong> technique to make <code>ItemWorker</code> depend on protocols instead. So this way, when we test this class, we can create mocked-up classes that conform to <code>NetworkProtocol</code> and <code>CacheRepositoryProtocol</code> that give us full control to test any network scenario or cache state that we want. If you never heard of this concept, I highly recommend that you read <a href="https://martinfowler.com/articles/injection.html#FormsOfDependencyInjection">this definition from Martin Fowler</a>. Mastering dependency injection will take your testing abilities to a whole new level.</p><p>If you need a little bit more of context to understand my implementation of <code>ItemWorker</code>, you can see the definition of the <code>NetworkProtocol</code>, <code>CacheRepositoryProtocol</code>, <code>ItemRequest</code> and <code>Item</code> bellow.</p><pre><code class="language-swift">protocol NetworkProtocol {
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void)
}

protocol CacheRepositoryProtocol {
    func get&lt;T: Codable&gt;(forKey: String) -&gt; T?
    func set&lt;T: Codable&gt;(item: T, forKey: String)
}

enum ItemRequest: NetworkRequest {
    case itemByID(id: String)
}

struct Item: Codable {
    let id: String
    let name: String
}
</code></pre><h2>XCTExpectation</h2><p>Now that we have an <code>ItemWorker</code> that meets the requirements, we should write a test to assert that the requirements are indeed met. Our worker class will fetch the <code>Item</code> from the network only if the <code>Item</code> is not cached.</p><p>First, we will define our test cases. I like to be really descriptive, using the function names to state what is being tested, and what should happen. So if in a future point of time this test fails, it is easy to understand what is broken.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    // Sut means subject under test. It is what we are testing here.
    private lazy var sut = ItemWorker()
    
    func test_requestItem_itemIsNotCached_expectRequestingItem() {

    }
    
    func test_requestItem_itemIsCached_expectNotRequestingItem() {

    }
}
</code></pre><p>Then, we should mock-up <code>Network</code> and <code>CacheRepository</code>, because we can't have our test to rely on network availability or cache state on the testing device. A good test should always pass if the code is correct, and it should always fail if the code is incorrect.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    let network = NetworkSpy()
    let cache = CacheRepositoryMock()
    private lazy var sut = ItemWorker(network: network, cache: cache)
    
    func test_requestItem_itemIsNotCached_expectRequestingItem() {

    }
    
    func test_requestItem_itemIsCached_expectNotRequestingItem() {

    }
}

final class NetworkSpy: NetworkProtocol {
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) {

    }
}

final class CacheRepositoryMock: CacheRepositoryProtocol {
    var cachedObjectToBeReturned: Codable?
    
    func get&lt;T: Codable&gt;(forKey: String) -&gt; T? {
        return cachedObjectToBeReturned as? T
    }
    
    func set&lt;T: Codable&gt;(item: T, forKey: String) {}
}
</code></pre><p>Note how I added the property <code>cachedObjectToBeReturned</code> to easily control a hypothetical scenario of the <code>CacheRepository</code> state.</p><p>Now we are ready to implement our test cases. Let's begin from the case where there is no cache, and <code>ItemWorker</code> should fetch it from the <code>Network</code>. And we'll do it using <code>XCTestExpectation</code>.</p><p>A <code>XCTestExpectation</code> is a promise that you are creating now to be fulfilled in the future (using <code>expectation.fulfill()</code>). It is meant to be used paired with the method <code>wait(for expectations: , timeout:)</code> that asserts that all the expectations are fulfilled in a given time interval. Take a look at the implementation of the first test case, so you can understand what that means. You can also read the <a href="https://developer.apple.com/documentation/xctest/asynchronous_tests_and_expectations/testing_asynchronous_operations_with_expectations">docs from Apple</a>.</p><pre><code class="language-swift">// First we adapted our mocked up Network to fulfill an expectation when something is requested
final class NetworkSpy: NetworkProtocol {
    var requestCompleteExpectation: XCTestExpectation?
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) {
        requestCompleteExpectation?.fulfill()
    }
}

// ...
final class ItemWorkerTests: XCTestCase {
    // ...
    func test_requestItem_itemIsNotCached_expectRequestingItem() {
        // Creates an expectation that will be fulfilled once the item is requested
        let expectation = XCTestExpectation(description: "itemRequest")
        network.requestCompleteExpectation = expectation
        // Mock up a state where the cache doesn't have the requested item
        cache.cachedObjectToBeReturned = nil
        // Requests
        sut.requestItem(withID: "1234", completion: { _ in })
        // Waits for a second, if the expectation IS NOT fulfilled, fails
        wait(for: [expectation], timeout: 1)
    }
    // ...
}
</code></pre><p>The test above should pass, because: - <code>CacheRepositoryMock</code> returns no item. - <code>NetworkSpy</code> is called, fulfilling the expectation. - The expectation that <code>wait</code> is waiting for, is fulfilled before the timeout of 1 second.</p><p>Now, to the test case where the <code>CacheRepository</code> does have the <code>Item</code> cached, and we should not request it from the <code>Network</code>, we will use the property <code>isInverted</code> from <code>XCTestExpectation</code>. This makes the expectation function the exact opposite way of a non-inverted one. This means that <code>wait(for expectations: , timeout:)</code> now asserts that the timeout expires before the expectation is fulfilled. For inverted expectations, if the expectation is fulfilled, the test fails. And this is perfect to assert that code is not executed in the future.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    // ...
    func test_requestItem_itemIsCached_expectNotRequestingItem() {
        // Creates an expectation that will be fulfilled once the item is requested
        let expectation = XCTestExpectation(description: "itemRequest")
        // Set the expectation to inveted, meaning that we expect it to not be fulfilled
        expectation.isInverted = true
        network.requestCompleteExpectation = expectation
        cache.cachedObjectToBeReturned = Item(id: "1234", name: "Mac")
        
        sut.requestItem(withID: "1234", completion: { _ in })
        // Waits for a second, if the expectation IS fulfilled, fails
        wait(for: [expectation], timeout: 1)
    }
    // ...
}
</code></pre><p>The test above should pass, because: - <code>CacheRepositoryMock</code> returns an item. - The worker returns this item not calling <code>NetworkSpy</code>, so the expectation is never fulfilled. - The 1 second timeout defined on the <code>wait</code> method expires.</p><h2>Pro tip: using reasonable timeouts</h2><pre><code class="language-swift">wait(for: [expectation], timeout: 10)
</code></pre><p>In the code above, if the expectation is not inverted, and it is fulfilled in 1 second, the test will pass without actually waiting the whole 10 seconds. But on the other hand, if it is an inverted expectation, the test will take 10 seconds to end the assertion.</p><p>Having tests that take long to complete is harmful to your project. This is especially important if you work on a large enterprise app, where having tests that clutter the CI/CD machines, decreases team productivity and costs the company money.</p><p>Thank you for reading! I hope this is was an useful learning. Take care and good coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/quick-tip-1</guid><title>Quick tip #1: Array copy-on-write</title><description>I'm on a quest to study data structures in Swift, and one really cool feature that Swift arrays implement is copy-on-write!</description><link>https://lucas1295santos.github.io/posts/quick-tip-1</link><pubDate>Sun, 24 May 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Quick tip #1: Array copy-on-write</h1><p>I'm studying data structures, and its implementations in Swift following the Udacity course <a href="https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011">Data Structures &amp; Algorithms in Swift</a> (I'm on early lessons, but from what I've seen so far, I recommend it). And one really nice thing that I learned on the arrays lesson, is that Swift arrays implement copy-on-write. But what does that mean?</p><p>Copy-on-write is a pattern that aims to save storage or memory allocation whenever it is possible by delaying copying a resource as long as it is possible. The copy only happens when someone writes on that resource, in other words, when someone edit, delete or add any information to it.</p><p>It is way easier to understand with some code, so here it goes.</p><pre><code class="language-swift">var originalArray = [1,2,3]
var copyArray = originalArray

originalArray.withUnsafeBufferPointer { (pointer) in
  print("originalArray: \(pointer)")
}
copyArray.withUnsafeBufferPointer { (pointer) in
  print("copyArray: \(pointer)")
}

print("Editing copyArray...")
copyArray[2] = 20

originalArray.withUnsafeBufferPointer { (pointer) in
    print("originalArray: \(pointer)")
}
copyArray.withUnsafeBufferPointer { (pointer) in
    print("copyArray: \(pointer)")
}
</code></pre><p>In the example above, I use <a href="https://developer.apple.com/documentation/swift/array/2994771-withunsafebufferpointer">withUnsafeBufferPointer</a> to get access to the pointer of the starting address of the array. When the code is executed, it outputs the following:</p><pre><code>originalArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
copyArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
Editing copyArray...
originalArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
copyArray: UnsafeBufferPointer(start: 0x0000600002cd95a0, count: 3)
</code></pre><p>You can see that prior to the edition of <code>copyArray</code> both arrays are stored at the same memory address, and only after I did a write operation on it all the values from <code>originalArray</code> were copied over to another memory address, so than the copy could be edited without changing anything at the original.</p><p>Since this all happens under the hood, in most cases it makes no practical difference if you are aware of this language characteristic. But maybe you have a really specific situation where you want to give more context to the code by reassigning one array to a different name, and now you know that you will be paying basically nothing for it in terms of memory usage.</p><p>Thank you for reading, take care, and good coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/first-post</guid><title>This blog is written in Swift!</title><description>Recently, I discovered [Publish](https://github.com/johnsundell/publish), a static website generator that uses Swift, written by [John Sundell](https://swiftbysundell.com).&lt;br&gt;&lt;/br&gt; The main idea is to declare all the pieces of your website like a *Swift Package*, and then using [Plot](https://github.com/JohnSundell/Plot) to generate HTML code using the type-safety of Swift, and finally using [Ink](https://github.com/JohnSundell/Ink) to render posts written in **Markdown**. (like this one!) &lt;br&gt;&lt;/br&gt; It may sound like a lot of tools to handle, but in reality, Publish already does most of the work for you.</description><link>https://lucas1295santos.github.io/posts/first-post</link><pubDate>Mon, 20 Apr 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>This blog is written in Swift!</h1><p>Recently, I discovered <a href="https://github.com/johnsundell/publish">Publish</a>, a static website generator that uses Swift, written by <a href="https://swiftbysundell.com">John Sundell</a>. The main idea is to declare all the pieces of your website like a <em>Swift Package</em> and then using <a href="https://github.com/JohnSundell/Plot">Plot</a> to generate HTML code using the type-safety of Swift, and finally using <a href="https://github.com/JohnSundell/Ink">Ink</a> to render posts written in <strong>Markdown</strong>. (like this one!) It may sound like a lot of tools to handle, but in reality, Publish already does most of the work for you.</p><p>Before digging into how Publish works, I highly recommend that you read the README of <a href="https://github.com/johnsundell/publish">Publish's Github</a> to have an overview on the framework, and all the step-by-step of how to <strong>install</strong> and <strong>setup</strong> a starter project.</p><p>It is worth noting that there you can find a <strong>HowTo</strong> folder where the community registers how to do things that they struggled at first but then figured it out.</p><h2>Files structure</h2><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post1_img1.png" alt="File structure" style="width:200px;"/><p>When you start a new <strong>Publish</strong> website, it will create a file structure like the one above. The first thing we'll do is to understand what is the basic website generated.</p><ul><li><em>Package.swift</em> is a file where you should declare dependencies for your project. If you never worked with Swift Package Manager, you can think of this file as a <em>Podfile</em> where you declare the <em>Cocoa pods</em> that you want to import. You also can learn more at this great article at <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager/">Swift by Sundell</a>.</li></ul><ul><li><em>Content</em> is where you'll add posts, audio, video, or any type of content your website is about. This very blog post is currently in this folder.</li></ul><ul><li><em>Output</em> folder is generated after you run <code>publish generate</code>, and <strong>this is the actual website</strong>. You shouldn't really code or add anything here, Publish will generate everything when you use the <code>generate</code> command.</li></ul><ul><li><em>Resources</em> folder is where you can store assets that your pages will use, and <strong>CSS</strong> styles as well. Currently, I have a <em>images</em> and <em>css</em> folders here. The image of the file structure above is stored int this folder.</li></ul><ul><li><em>Sources</em> folder is where you'll code! Currently, there is a folder with your project's name and a <code>main.swift</code> inside.</li></ul><h2>main.swift</h2><p>This file declares your website through a structure that implements <code>Website</code>, and defines the publishing steps for it.</p><pre><code class="language-swift">struct Bla: Website {
    // Website configurations go here
}
</code></pre><p>And outside of the Website defining structure, you'll have the publish step. This is what will be executed on <code>publish deploy</code>.</p><pre><code class="language-swift">try Bla().publish(
  withTheme: .custom,
  additionalSteps: [
    .deploy(using: .git("git@github.com-lucas1295santos:lucas1295santos/lucas1295santos.github.io.git"))
  ]
)
</code></pre><p>On the example above I did a really basic publish workflow, where I use <strong>Github Pages</strong> to host this website and make it available at this domain. I also declare that I want to use a theme called <code>custom</code> to render this website (I'll talk about that in a bit). But this can easily become a robust deployment pipeline if your website needs to.</p><pre><code class="language-swift">try Bla().publish(using: [
    .step1(),
    .step2(),
    .step3()
])
</code></pre><h2>Custom theme</h2><p>To give your website some visual identity, you'll probably want to not use the default theme and create your own. I do this by instantiating a new <code>Theme</code> passing a <code>HTMLFactory</code> and the <strong>CSS</strong> resources that I'll use, making it available as a static variable of <code>Theme</code> just to make it easily accessible on my <strong>main.swift</strong>.</p><pre><code class="language-swift">extension Theme {
    static var custom: Self {
        Theme(
            htmlFactory: CustomHTMLFactory(),
            resourcePaths: ["Resources/css/styles.css"]
        )
    }
}
</code></pre><p>The <code>CustomHTLMFactory</code> on the code above is an implementation of the <code>HTMLFactory</code> protocol that generates the HTML layout for each piece of the website.</p><pre><code class="language-swift">private struct CustomHTMLFactory&lt;Site: Website&gt;: HTMLFactory {
    func makeIndexHTML(for index: Index, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeSectionHTML(for section: Section&lt;Site&gt;, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeItemHTML(for item: Item&lt;Site&gt;, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makePageHTML(for page: Page, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeTagListHTML(for page: TagListPage, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML? {}
    
    func makeTagDetailsHTML(for page: TagDetailsPage, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML? {}
}
</code></pre><p>I'll not dig any deeper on how to use <strong>Plot</strong> to create the HTML layout required on each method from <code>HTMLFactory</code>, but I highly recommend that you take a look at the implementation of the <code>foundation</code> theme (the one that comes with <strong>Publish</strong>) at the file <code>Theme+Foundation.swift</code> on the <code>Publish</code> package. Copy it, try to change it a little bit, and you will get a hang on how it works in no time (especially if you know any HTML).</p><h2>Wrapping up</h2><p>I'm excited about this framework, and it's being a joy to work with it! And I'm still learning everything that it can do, so I'll post more about it as I learn.</p><p>I Hope that this post gives you a good idea of what it is, and how to get started. And besides the documentations that I referenced throughout the post, you might want to check out <a href="https://youtu.be/JqdS-oi96Gk">this hands-on video</a> from Kilo Loco about getting started on Publish.</p><p>Thank you for reading, take care, and good coding!</p>]]></content:encoded></item></channel></rss>