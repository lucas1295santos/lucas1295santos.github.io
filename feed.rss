<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Lucas Oliveira dot Tech</title><description>Topics about Swift and Engineering</description><link>https://lucas1295santos.github.io/</link><language>en</language><lastBuildDate>Thu, 1 Oct 2020 12:04:15 -0300</lastBuildDate><pubDate>Thu, 1 Oct 2020 12:04:15 -0300</pubDate><ttl>250</ttl><atom:link href="https://lucas1295santos.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/test-doubles</guid><title>Writing good tests with Tests Doubles</title><description>Writing unit tests is one of the key responsibilities of a developer. Although writing a test is not that hard, setting up a controlled environment where you can unit test one component might be challenging, especially if your component is surrounded by legacy code. Setting up testing doubles is a winner technique to tackle this problem.</description><link>https://lucas1295santos.github.io/posts/test-doubles</link><pubDate>Thu, 1 Oct 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Writing good tests with Tests Doubles</h1><p>Writing unit tests is one of the key responsibilities of a developer. Although writing a test is not that hard, setting up a controlled environment where you can unit test one component might be challenging, especially if your component is surrounded by legacy code. Setting up testing doubles is a winner technique to tackle this problem.</p><p>If you are starting out on unit tests, you may already face issues like testing passing on your machine, and failing on your teammate's, or tests randomly failing without you making any changes related to the tests. And if you never faced issues like that, eventually, you will. Frequently those problems are due to the component that you are testing directly or indirectly depending on a resource that might change over executions, like responses from network requests, DataBase state, UserDefaults state, or even variables of a singleton.</p><p>Let's take a look at this example:</p><pre><code class="language-swift">// This label is part of my ViewController. If the user already registered its name, this label
// should greet by the name, else, it will greet the user as Guest.
class ViewController: UIViewController {
    var greetingsLabel = UILabel()

    func configure() {
        let userName = UserData().getUserName() ?? "Guest"
        greetingsLabel.text = "Hello, \(userName)!"
    }
    /*
        More code here...
    */
}

// And this is our UserData class, it saves and gets the user name from UserDefaults.

class UserData {
    func saveUserName(name: String) {
        UserDefaults.standard.setValue(name, forKey: "USER_NAME")
    }
    
    func getUserName() -&gt; String? {
        UserDefaults.standard.string(forKey: "USER_NAME")
    }
}

// Now we will unit test the logic of our ViewController

class ViewControllerTests: XCTestCase {
    func test_greetingsLabel_beforeSettingName_expectNameToBeGuest() {
        let sut = ViewController()
        
        sut.configure()

        XCTAssertEqual(sut.greetingsLabel.text, "Hello, Guest!")
    }
    
    func test_greetingsLabel_afterSettingName_expectNameToEqualsUserName() {
        let sut = ViewController()
        UserData().saveUserName(name: "John")

        sut.configure()
        
        XCTAssertEqual(sut.greetingsLabel.text, "Hello, John!")
    }
}
</code></pre><p>After writing this code, you can test them on the simulator, and it will work fine. You can run the tests, and they will pass, as they should. After asserting that the code works, you start working on your next feature, and when you execute the tests you will be taken by surprise as the test <code>test_greetingsLabel_beforeSettingName_expectNameToBeGuest</code> will fail, even if you didn't do any change to the label <code>greetingsLabel</code> on the <code>ViewController</code> or the data class <code>UserData</code>.</p><p>The test fails because the second time you execute this test, the simulator that you run your tests on has already saved the value "John" for the key <code>USER_NAME</code> on UserDefaults. This value is set on the second test (<code>test_greetingsLabel_afterSettingName_expectNameToEqualsUserName</code>). So instead of setting the text to "Hello, Guest!", it will set to "Hello, John!", therefore failing the test.</p><h2>What is a Test Double</h2><p>In the movies, a stunt double is a professional that replaces the actor on interpreting a character in scenes of risky stunts, or highly demanding athletic skills. The stunt double should be similar enough to the actor to convince the audience and convey the idea that the character is doing the stunts in the movie. The idea of a test double is really similar: a test double is a class that replaces the desired class during tests.</p><p>Think about the example we just saw, where the tests failed after executing two times. A really nice way to solve our problem would be to somehow use the class <code>UserData</code> just on our app's "production" code, but when testing we would use a class just like <code>UserData</code>, but instead of getting information on UserDefaults, it could return whatever we want. So when testing the ViewController's label, we could set this class to return John, and assert that the text of the label is "Hello, John!", and on the next text set it to return nil, and assert that text is "Hello, Guest!". This way our test would not depend on UserDefaults and would be consistent for sure.</p><p>This is the concept of a test double, and the main way to achieve that is by creating a protocol that defines the methods that a <code>UserData</code> class should have.</p><pre><code class="language-swift">protocol UserDataProtocol {
    func saveUserName(name: String)
    func getUserName() -&gt; String?
}

// After creating the protocol, we make UserData conform to that protocol

class UserData: UserDataProtocol {
    func saveUserName(name: String) {
        UserDefaults.standard.setValue(name, forKey: "USER_NAME")
    }
    
    func getUserName() -&gt; String? {
        UserDefaults.standard.string(forKey: "USER_NAME")
    }
}

// And we create the test double of UserData

class UserDataMock: UserDataProtocol {
    func saveUserName(name: String) {}
    
    var userNameToBeReturned: String?
    func getUserName() -&gt; String? {
        return userNameToBeReturned
    }
}
</code></pre><p>Notice how we created a variable <code>userNameToBeReturned</code> to give us total control of what the method <code>getUserName</code> returns, and it does not depends on UserDefaults. The next step to solve the test problem is to make it possible to use <code>UserData</code> when running the app, and <code>UserDataMock</code> when testing.</p><h2>Dependency Inversion Principle</h2><p>The Dependency Inversion Principle (<code>DIP</code>) is part of the <code>SOLID</code> set of good practices for Object-Oriented Design. The main idea of this principle is that your objects should depend on abstractions and not concrete implementations. And as in our last example, protocols are a good way of creating abstractions.</p><p>Depending on abstractions gives you a lot of flexibility to change the implementation of a component without propagating changes to its neighbors (the components that interact with it). And also the abstractions will help us to improve testability, as we can easily slip in a test double to replace a dependency at testing time.</p><p>Let's take a look at how we could make our <code>ViewController</code> stop depending on <code>UserData</code> and depending on the abstraction <code>UserDataProtocol</code> instead.</p><pre><code class="language-swift">class ViewController: UIViewController {
    var greetingsLabel = UILabel()
    // Holding an instance of an object that implements UserDataProtocol
    let userData: UserDataProtocol
    
    // We set the default value of userData as a new instance of a UserData object by default
    // Doing it this way, it is important to remember to init this class passing a new instance
    // of UserDataMock when testing
    init(userData: UserDataProtocol = UserData()) {
        self.userData = userData
        super.init(nibName: nil, bundle: nil)
    }
    
    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    func configure() {
        // Now instead of creating a UserData instance, and using it. We will use the 
        // instance provided at init time, that could be the real UserData, or the
        // test double UserDataMock.
        let userName = userData.getUserName() ?? "Guest"
        greetingsLabel.text = "Hello, \(userName)!"
    }
}
</code></pre><p>Now that the <code>ViewController</code> is set up, let's rewrite the <code>ViewControllerTests</code> using test doubles to have a reliable test.</p><pre><code class="language-swift">    func test_greetingsLabel_userNameIsNil_expectNameToBeGuest() {
        let userData = UserDataMock()
        // sets up UserDataMock to return nil when getUserName is called
        userData.userNameToBeReturned = nil
        // makes the ViewController use the test double
        let sut = ViewController(userData: userData)
        
        sut.configure()
        
        XCTAssertEqual(sut.greetingsLabel.text, "Hello, Guest!")
    }
    
    func test_greetingsLabel_userNameIsNotNil_expectNameToEqualsUserName() {
        let userData = UserDataMock()
        // sets up UserDataMock to return John when getUserName is called
        userData.userNameToBeReturned = "John"
        let sut = ViewController(userData: userData)
        
        sut.configure()
         
        XCTAssertEqual(sut.greetingsLabel.text, "Hello, John!")
    }
</code></pre><p>Finally, the <code>ViewControllerTest</code> is reliable, as the logic of <code>greetingsLabel</code> is isolated, and it does not depend on any external component.</p><h2>Final thoughts</h2><p>To master the usage of test doubles, you have to master writing testable code, which requires a lot of practice writing code with bad testability and than improving it.</p><p>One thing to keep in mind is that you always have to decide which dependencies of your class can be decoupled from it, meaning that if the dependency change implementation, the class can continue working without changing as well. So on the class's tests, you can use test doubles to substitute every decoupled dependency, and test the class in a reliable and consistent environment, where you can easily test any scenario in a way that the tests will only fail if internal logic changes.</p><h2>What's next?</h2><p>If you want to know more about <code>DIP</code> and the other <code>SOLID</code> principles, <a href="https://hackernoon.com/solid-principles-made-easy-67b1246bcdf">this article from hackernoon</a> is a great light start. And <a href="https://github.com/ochococo/OOD-Principles-In-Swift">This repo from ochococo</a> gives nice and easy examples and has links to in-depth articles that are really good reading.</p><p>If you want to know how to unit test asynchronous code, check out [my article about it]. (https://www.lucasoliveira.tech/posts/async-tests)</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/improving-error-handling-in-your-app</guid><title>Improving Error Handling in your App in Swift.</title><description>We want our software to be error-proof, but in reality, error scenarios will always exist.&lt;br&gt;&lt;/br&gt;So this article's objective is to explain why you should handle errors on your app, give you a rule of thumb on when treating errors, and give some practical improvements you could apply on your app.</description><link>https://lucas1295santos.github.io/posts/improving-error-handling-in-your-app</link><pubDate>Tue, 4 Aug 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Improving Error Handling in your App in Swift.</h1><p>We want our software to be error-proof, but in reality, error scenarios will always exist.</p><p>So this article's objective is to explain why you should handle errors on your app, give you a rule of thumb on when treating errors, and give some practical improvements you could apply on your app.</p><h2>Why handling errors?</h2><h3>Finding errors <em>asap</em></h3><p>Worse than finding a bug on your production app is learning that the bug you just found is around for several releases.</p><p>Below is the recipe of failure to ship a hard to catch bug.</p><pre><code class="language-swift">func callMerchant(with telefoneNumber: String?) {
    guard let phone = telefoneNumber else { return }
    // Calling a phone number code goes here
}
</code></pre><p>If for some reason this function is ever invoked with a <code>nil</code> telefoneNumber, it will exit without trying to make the phone call, and this could lead to a useless call button on your user interface, that does nothing when pressed.</p><h3>Improving User Experience (UX)</h3><p>It might be really frightening to a user with no technology background to be prompted with an error dialog full of tech words and error codes, especially if he just made a critical action like a purchase. Take a look at the picture on the left.</p><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post4_img1.png" alt="Error notification" style="width:500px;"/><p>On the other hand, the picture to the right explains what happened and how the user could proceed.</p><h3>Recovering from an error state to a success</h3><p>With a really well-crafted error recovering strategy you could even recover a user that got in an error state, to the main flow of your application that will lead to a goal (like making a purchase).</p><p>Recovering from errors is not only important for the tech team, but it is also beneficial for the business as a whole. Commonly, digital products lose some conversion percentual points due to techinical issues. And good error handling might mitigate this issue.</p><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post4_image2.png" alt="Error state recovery" style="width:500px;"/><p>The example above gives clear instructions and even some shortcuts on how to get out of this error and try another product.</p><h2>Rule of thumb to handling errors</h2><p>Maybe your App is nothing like any of the examples I gave so far, and you are not sure where you could improve error handling in your app. So you could follow this rule of thumb to know where you should consider handling errors.</p><p>Consider handling errors every time you...</p><ul><li>...make a request to an external source (networking)</li><li>...capture user input</li><li>...encode or decode some data</li><li>...escape a function prior to its full execution (early return)</li></ul><h2>Practical improvements for your App</h2><h3>Monitoring tool</h3><p>This is the most important improvement that you could do! With a monitoring tool, you can have useful data to discover, understand, and prioritize errors.</p><p>By understanding the volumetry of an error, you could decide between adding a fix to the next version, creating a new version as soon as possible just to fix that error (hotfix), or turn off some remote configuration to disable the problematic feature.</p><p>There are several monitoring tools available on the market, like <a href="https://www.dynatrace.com/">Dynatrace</a> or <a href="https://newrelic.com/">New Relic</a>. The monitoring tool that I use at iFood is <a href="https://logz.io/">Logz.io</a>. It provides all the utility that we need to keep track of error logs:</p><ul><li>Logs over time</li><li>Querying for specific logs</li><li>Configuring alerts to send to Slack</li><li>Dashboard creation</li></ul><p>With a good tool setup in the project, it is time to bring a monitoring culture to the team. You could start establishing some new tasks that should be done at every new feature development.</p><ul><li>Map all error cases</li><li>Create logs for the error cases</li><li>Create alerts for the logs to get any critical scenario. It is important that the alerts are sent to a channel where all the devs have access.</li><li>Create a Dashboard containing all the logs for that feature</li><li>Monitor the dashboard periodically. You could make a recurrent event on the calendar to be reminded.</li></ul><h3>Swift's Error protocol</h3><p>Swift's error protocol allows you to create expressive errors that will give you useful information to find and act on a possible issue. Having rich errors will also help you to create insightful dashboards and precise alerts on your monitoring tool.</p><p>Below, there is a simple example of how to use it in an enumerator.</p><pre><code class="language-swift">enum SimpleError: Error {
    case generic
    case network(payload: [String: Any])
}
</code></pre><p>In this example, we will capture the payload of the request that caused a network error. Doing so, we could look for patterns on the payloads, and understand what really causes the error.</p><p><strong>Disclaimer:</strong> if you want to do an error treatment like that one where you send the payload from a network request, you must mask any user sensitive data.</p><p>You could also conform to this protocol in a <code>struct</code> so you can have as much information as you need on the error. This is useful when you want to custom tailor an error for a very specific scenario.</p><pre><code class="language-swift">struct StructError: Error {
    enum ErrorType {
        case one
        case two
    }
    let line: Int
    let file: String
    let type: ErrorType
    let isUserLoggedIn: Bool
}
// ...
func functionThatThrowsError throws {
    throw StructError(line: 53, file: "main.swift", type: .one, isUserLoggedIn: false)
}
</code></pre><p>Later on your monitoring tool, you could create a dashboard comparing the volumetry when the user has logged in again when it is not logged in, so you can understand if this is a relevant factor that leads to the error.</p><p>And if you want the error to also contain localized human-readable messages to display, you could also conform to <code>LocalizedError</code> as shown below.</p><pre><code class="language-swift">enum RegisterUserError: Error {
    case emptyName
    case invalidEmail
    case invalidPassword
}

extension RegisterUserError: LocalizedError {
    // errorDescription is the one that you get when using error.localizedDescription
    var errorDescription: String? {
        switch self {
        case .emptyName:
            return "Name can't be empty"
        case .invalidEmail:
            return "Invalid email format"
        case .invalidPassword:
            return "The password must be at least 8 characters long"
        }
    }
}
</code></pre><p>Now if an error of type <code>RegisterUserError</code> happens, you could display <code>error.localizedDescription</code> to the user.</p><h3>Don't use <code>nil</code> as an error</h3><p>Take a look at the function below, it is uncanny how familiar this code is.</p><pre><code class="language-swift">func getUserPreferences() -&gt; UserPreferences? {
    let dataFromKey = UserDefaults.standard.data.(forKey: "user_preferences")
    guard let data = dataFromKey else { return nil }
    let decoder = JSONDecoder()
    let userPreferences = try? decoder.decode(UserPreferences.self, from: data)
    return userPreferences
}
</code></pre><p>At first glance, pretty standard implementation. Nothing wrong with that. But if this code ever returns <code>nil</code>, how would you know if there are no <code>UserPreferences</code> set yet or if there is something wrong with our encoding or decoding of this object?</p><p>If we want to ship this code to production it would be really nice that the caller of this function would create and save a new <code>UserPreferences</code> with default preferences if there are none set, or log an error to our monitoring tool if the decoding failed, so we could investigate and fix it.</p><p>Returning <code>nil</code> when some error occurs really limits the options you have to handle it.</p><p>You could instead make the function throwable, declaring it with <code>throws</code> and removing the optional mark <code>?</code> from the decoder's <code>try</code>. If you never used <code>throws</code> in Swift, I strongly recommend you read this <a href="https://www.swiftbysundell.com/basics/error-handling">article from Sundell</a> and the <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html">Swift docs</a>, as I'll not cover the basics on what it is and how it works.</p><pre><code class="language-swift">func getUserPreferences() throws -&gt; UserPreferences {
    let dataFromKey = UserDefaults.standard.data.(forKey: "user_preferences")
    guard let data = dataFromKey else {
        throw UserPreferencesError.noUserPreferences
    }
    let decoder = JSONDecoder()
    let userPreferences = try decoder.decode(UserPreferences.self, from: data)
    return userPreferences
}
</code></pre><p><strong>Note: </strong> on the example above, it would be correct to return <code>nil</code> on the <code>else</code> clause of the <code>guard</code>, as <code>nil</code> is in fact the representation of the absence of value. I went all-in on throws just to illustrate better how it could be used.</p><p>But what if the errors happen in an asynchronous context? Is it time to return <code>nil</code>? Still, not ideal, instead, we could use other Swift's nice feature for error handling that suits really well in asynchronous contexts: <code>Result</code>.</p><p><code>Result</code> is an <code>enum</code> with the form <code>Result&lt;Success, Failure&gt; where Failure: Error</code> that has a <code>success</code> case with the result of the request as an associated value, and a <code>failure</code> case that brings an <code>Error</code> associated. Again, if you never heard of <code>Result</code> before, I strongly recommend this quick read from <a href="https://www.hackingwithswift.com/articles/161/how-to-use-result-in-swift#:~:text=Swift's%20Result%20type%20is%20implemented,conforms%20to%20Swift's%20Error%20type.&text=Even%20in%20this%20simple%20scenario%2C%20Result%20has%20provided%20two%20benefits.">hacking with swift</a>.</p><p>If our <code>getUserPreferences</code> fetch its data from a server instead of <code>UserDefaults</code>, we could rewrite it like the example below.</p><pre><code class="language-swift">func getUserPreferences(userID id: String, completion: @escaping (Result&lt;UserPreferences, Error&gt;) -&gt; Void) {
    Network.request(.userPreferences(userID: id)) { result in
      switch result {
      case .success(let data):
          do {
              let decoder = JSONDecoder()
              let userPreferences = try decoder.decode(UserPreferences.self, from: data)
              completion(.sucess(userPreferences))
          } catch {
              completion(.failure(error))
          }
      case .failure(let error):
          completion(.failure(error))
      }
    }
}
</code></pre><p>This way, the caller function could differentiate an encoding error from a network error, and log it.</p><h3>Separate error handling from the actual functionality</h3><p>If you are familiar with the <code>SOLID</code> principles, you know the importance of the <em>Single Responsibility Principle (SRP)</em>. The <em>SRP</em> says that our software units should have a single responsibility. What is a responsibility depends on the size of the software unit, the responsibility that a function can have is more narrow than the responsibility that a class or a module could handle.</p><p>Take a look on the example below:</p><pre><code class="language-swift">func registerUser(_ user: User) throws {
    guard user.name.isEmpty == false else {
        throw RegisterUserError.emptyName
    }
    guard isValid(email: user.email) else {
        throw RegisterUserError.invalidEmail
    }
    guard isValid(password: user.password) else {
        throw RegisterUserError.invalidPassword
    }
    /*
        Code that registers a user goes here
    */
}
</code></pre><p>The function <code>registerUser</code> breaks <em>SRP</em> and it is not easy to read because the code that actually register the user is at the end of the function, with all the validation rules first.</p><p>We could greatly improve this function by separating the error handling responsibility from the user registering responsibility.</p><pre><code class="language-swift">func registerUser(_ user: User) throws {
    try validateUser(user)
    /*
        Code that registers a user goes here
    */
}

func validateUser(_ user: User) throws {
    guard user.name.isEmpty == false else {
        throw RegisterUserError.emptyName
    }
    guard isValid(email: user.email) else {
        throw RegisterUserError.invalidEmail
    }
    guard isValid(password: user.password) else {
        throw RegisterUserError.invalidPassword
    }
}
</code></pre><p>Conforming to the <em>SRP</em> made this function that much easier to read.</p><h2>Recap</h2><ul><li>üòå Don't leave errors unhandled, your users will appreciate it.</li><li>‚òÅÔ∏è Use a monitoring tool on your project.</li><li>‚ù§Ô∏è Use Swift's <code>Error</code> protocol to get expressive and useful errors.</li><li>üôÖ‚Äç‚ôÇÔ∏è Don't use <code>nil</code> as an error.</li><li>üë®‚Äçüíª Separate error validation and treatment from the actual functionality.</li></ul><h2>What's next?</h2><p>If you are interested in error handling, chapter 6 of <em>Clean Code from Robert C. Martin (a.k.a Uncle Bob)</em> is a must-read. This chapter was the biggest reference to this article, and it was what really drew my attention to the importance of handling errors. I consider this book a must-have for any software engineer, so you might as well <a href="https://www.amazon.com.br/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">get it on Amazon</a>.</p><p>If you want to know more about <code>SRP</code> and the other <code>SOLID</code> principles, <a href="https://hackernoon.com/solid-principles-made-easy-67b1246bcdf">this article from hackernoon</a> is a great light start. And <a href="https://github.com/ochococo/OOD-Principles-In-Swift">This repo from ochococo</a> gives nice and easy examples and has links to in-depth articles that are really good reading.</p><p>Thank you for reading! I hope this is was insightful and that you can apply those ideas on your projects. Take care and good error handling!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/async-tests</guid><title>Testing asynchronous code</title><description>When you are starting out on testing your code, you might find asynchronous methods a little bit tricky to test. &lt;br&gt;&lt;/br&gt; But do not worry, *XCTestExpectation* got you covered if you want to assert that an async block *will* execute, or even assert that it *will not* execute.</description><link>https://lucas1295santos.github.io/posts/async-tests</link><pubDate>Tue, 7 Jul 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Testing asynchronous code</h1><p>When you are starting out on testing your code, you might find asynchronous methods a little bit tricky to test.</p><p>But do not worry, <code>XCTestExpectation</code> got you covered if you want to assert that an async block <strong>will</strong> execute, or even assert that it <strong>will not</strong> execute.</p><p>In this post, I'll show you a really common case where you'll want to test an asynchronous method, and how to use <code>XCTestExpectation</code> to create an expectation that a block will be executed on the future, and how to create an inverted expectation to assert that a block will not be executed on the future.</p><h2>The use case</h2><p>Let's say that you are creating a feature that displays information about an item that your app sells. This feature will download the item details from an endpoint on a server whenever the user selects an item from a list. Then you will get the item ID and make an HTTP request to this endpoint to retrieve the item details. But to be more efficient on data usage, you also should cache every item fetched, so if the user wants to see details of an item that was already cached, instead of fetching it from the endpoint, you'll return the cached item.</p><p>To achieve this goal, this feature will have an <code>ItemWorker</code> class. It's objective is to return an item, given an ID. This class will contain the mechanism to get the item from a cache through a <code>CacheRepository</code> or, request it to the endpoint using <code>Network</code>.</p><p>This is a possible implementation of this class:</p><pre><code class="language-swift">final class ItemWorker {
    private let network: NetworkProtocol
    private let cache: CacheRepositoryProtocol
    
    init(
        network: NetworkProtocol = Network.shared,
        cache: CacheRepositoryProtocol = CacheRepository.shared
    ) {
        self.network = network
        self.cache = cache
    }
    
    func requestItem(withID id: String, completion: @escaping (Result&lt;Item, Error&gt;) -&gt; Void) {
        // If the cache contains the item, return the item
        if let cachedItem: Item = cache.get(forKey: id) {
            completion(.success(cachedItem))
        } else {
            let request = ItemRequest.itemByID(id: id)
            // Request an item passing the ID
            network.request(request) { [weak self] (result: Result&lt;Item, Error&gt;) in
                if case let Result.success(item) = result {
                    // Cache the item if succeded
                    self?.cache.set(item: item, forKey: item.id)
                }
                // Return what was fetched
                completion(result)
            }
        }
    }
}
</code></pre><p>Notice on this example that <code>Network</code> and <code>CacheRepository</code> are <strong>singletons</strong>, but however, I didn't use their shared instance directly. I used a <strong>Dependency injection</strong> technique to make <code>ItemWorker</code> depend on protocols instead. So this way, when we test this class, we can create mocked-up classes that conform to <code>NetworkProtocol</code> and <code>CacheRepositoryProtocol</code> that give us full control to test any network scenario or cache state that we want. If you never heard of this concept, I highly recommend that you read <a href="https://martinfowler.com/articles/injection.html#FormsOfDependencyInjection">this definition from Martin Fowler</a>. Mastering dependency injection will take your testing abilities to a whole new level.</p><p>If you need a little bit more of context to understand my implementation of <code>ItemWorker</code>, you can see the definition of the <code>NetworkProtocol</code>, <code>CacheRepositoryProtocol</code>, <code>ItemRequest</code> and <code>Item</code> bellow.</p><pre><code class="language-swift">protocol NetworkProtocol {
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void)
}

protocol CacheRepositoryProtocol {
    func get&lt;T: Codable&gt;(forKey: String) -&gt; T?
    func set&lt;T: Codable&gt;(item: T, forKey: String)
}

enum ItemRequest: NetworkRequest {
    case itemByID(id: String)
}

struct Item: Codable {
    let id: String
    let name: String
}
</code></pre><h2>XCTExpectation</h2><p>Now that we have an <code>ItemWorker</code> that meets the requirements, we should write a test to assert that the requirements are indeed met. Our worker class will fetch the <code>Item</code> from the network only if the <code>Item</code> is not cached.</p><p>First, we will define our test cases. I like to be really descriptive, using the function names to state what is being tested, and what should happen. So if in a future point of time this test fails, it is easy to understand what is broken.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    // Sut means subject under test. It is what we are testing here.
    private lazy var sut = ItemWorker()
    
    func test_requestItem_itemIsNotCached_expectRequestingItem() {

    }
    
    func test_requestItem_itemIsCached_expectNotRequestingItem() {

    }
}
</code></pre><p>Then, we should mock-up <code>Network</code> and <code>CacheRepository</code>, because we can't have our test to rely on network availability or cache state on the testing device. A good test should always pass if the code is correct, and it should always fail if the code is incorrect.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    let network = NetworkSpy()
    let cache = CacheRepositoryMock()
    private lazy var sut = ItemWorker(network: network, cache: cache)
    
    func test_requestItem_itemIsNotCached_expectRequestingItem() {

    }
    
    func test_requestItem_itemIsCached_expectNotRequestingItem() {

    }
}

final class NetworkSpy: NetworkProtocol {
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) {

    }
}

final class CacheRepositoryMock: CacheRepositoryProtocol {
    var cachedObjectToBeReturned: Codable?
    
    func get&lt;T: Codable&gt;(forKey: String) -&gt; T? {
        return cachedObjectToBeReturned as? T
    }
    
    func set&lt;T: Codable&gt;(item: T, forKey: String) {}
}
</code></pre><p>Note how I added the property <code>cachedObjectToBeReturned</code> to easily control a hypothetical scenario of the <code>CacheRepository</code> state.</p><p>Now we are ready to implement our test cases. Let's begin from the case where there is no cache, and <code>ItemWorker</code> should fetch it from the <code>Network</code>. And we'll do it using <code>XCTestExpectation</code>.</p><p>A <code>XCTestExpectation</code> is a promise that you are creating now to be fulfilled in the future (using <code>expectation.fulfill()</code>). It is meant to be used paired with the method <code>wait(for expectations: , timeout:)</code> that asserts that all the expectations are fulfilled in a given time interval. Take a look at the implementation of the first test case, so you can understand what that means. You can also read the <a href="https://developer.apple.com/documentation/xctest/asynchronous_tests_and_expectations/testing_asynchronous_operations_with_expectations">docs from Apple</a>.</p><pre><code class="language-swift">// First we adapted our mocked up Network to fulfill an expectation when something is requested
final class NetworkSpy: NetworkProtocol {
    var requestCompleteExpectation: XCTestExpectation?
    func request&lt;T: Codable&gt;(_ request: NetworkRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) {
        requestCompleteExpectation?.fulfill()
    }
}

// ...
final class ItemWorkerTests: XCTestCase {
    // ...
    func test_requestItem_itemIsNotCached_expectRequestingItem() {
        // Creates an expectation that will be fulfilled once the item is requested
        let expectation = XCTestExpectation(description: "itemRequest")
        network.requestCompleteExpectation = expectation
        // Mock up a state where the cache doesn't have the requested item
        cache.cachedObjectToBeReturned = nil
        // Requests
        sut.requestItem(withID: "1234", completion: { _ in })
        // Waits for a second, if the expectation IS NOT fulfilled, fails
        wait(for: [expectation], timeout: 1)
    }
    // ...
}
</code></pre><p>The test above should pass, because: - <code>CacheRepositoryMock</code> returns no item. - <code>NetworkSpy</code> is called, fulfilling the expectation. - The expectation that <code>wait</code> is waiting for, is fulfilled before the timeout of 1 second.</p><p>Now, to the test case where the <code>CacheRepository</code> does have the <code>Item</code> cached, and we should not request it from the <code>Network</code>, we will use the property <code>isInverted</code> from <code>XCTestExpectation</code>. This makes the expectation function the exact opposite way of a non-inverted one. This means that <code>wait(for expectations: , timeout:)</code> now asserts that the timeout expires before the expectation is fulfilled. For inverted expectations, if the expectation is fulfilled, the test fails. And this is perfect to assert that code is not executed in the future.</p><pre><code class="language-swift">final class ItemWorkerTests: XCTestCase {
    // ...
    func test_requestItem_itemIsCached_expectNotRequestingItem() {
        // Creates an expectation that will be fulfilled once the item is requested
        let expectation = XCTestExpectation(description: "itemRequest")
        // Set the expectation to inveted, meaning that we expect it to not be fulfilled
        expectation.isInverted = true
        network.requestCompleteExpectation = expectation
        cache.cachedObjectToBeReturned = Item(id: "1234", name: "Mac")
        
        sut.requestItem(withID: "1234", completion: { _ in })
        // Waits for a second, if the expectation IS fulfilled, fails
        wait(for: [expectation], timeout: 1)
    }
    // ...
}
</code></pre><p>The test above should pass, because: - <code>CacheRepositoryMock</code> returns an item. - The worker returns this item not calling <code>NetworkSpy</code>, so the expectation is never fulfilled. - The 1 second timeout defined on the <code>wait</code> method expires.</p><h2>Pro tip: using reasonable timeouts</h2><pre><code class="language-swift">wait(for: [expectation], timeout: 10)
</code></pre><p>In the code above, if the expectation is not inverted, and it is fulfilled in 1 second, the test will pass without actually waiting the whole 10 seconds. But on the other hand, if it is an inverted expectation, the test will take 10 seconds to end the assertion.</p><p>Having tests that take long to complete is harmful to your project. This is especially important if you work on a large enterprise app, where having tests that clutter the CI/CD machines, decreases team productivity and costs the company money.</p><p>Thank you for reading! I hope this is was an useful learning. Take care and good coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/quick-tip-1</guid><title>Quick tip #1: Array copy-on-write</title><description>I'm on a quest to study data structures in Swift, and one really cool feature that Swift arrays implement is copy-on-write!</description><link>https://lucas1295santos.github.io/posts/quick-tip-1</link><pubDate>Sun, 24 May 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>Quick tip #1: Array copy-on-write</h1><p>I'm studying data structures, and its implementations in Swift following the Udacity course <a href="https://www.udacity.com/course/data-structures-and-algorithms-in-swift--ud1011">Data Structures &amp; Algorithms in Swift</a> (I'm on early lessons, but from what I've seen so far, I recommend it). And one really nice thing that I learned on the arrays lesson, is that Swift arrays implement copy-on-write. But what does that mean?</p><p>Copy-on-write is a pattern that aims to save storage or memory allocation whenever it is possible by delaying copying a resource as long as it is possible. The copy only happens when someone writes on that resource, in other words, when someone edit, delete or add any information to it.</p><p>It is way easier to understand with some code, so here it goes.</p><pre><code class="language-swift">var originalArray = [1,2,3]
var copyArray = originalArray

originalArray.withUnsafeBufferPointer { (pointer) in
  print("originalArray: \(pointer)")
}
copyArray.withUnsafeBufferPointer { (pointer) in
  print("copyArray: \(pointer)")
}

print("Editing copyArray...")
copyArray[2] = 20

originalArray.withUnsafeBufferPointer { (pointer) in
    print("originalArray: \(pointer)")
}
copyArray.withUnsafeBufferPointer { (pointer) in
    print("copyArray: \(pointer)")
}
</code></pre><p>In the example above, I use <a href="https://developer.apple.com/documentation/swift/array/2994771-withunsafebufferpointer">withUnsafeBufferPointer</a> to get access to the pointer of the starting address of the array. When the code is executed, it outputs the following:</p><pre><code>originalArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
copyArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
Editing copyArray...
originalArray: UnsafeBufferPointer(start: 0x0000600002ca3320, count: 3)
copyArray: UnsafeBufferPointer(start: 0x0000600002cd95a0, count: 3)
</code></pre><p>You can see that prior to the edition of <code>copyArray</code> both arrays are stored at the same memory address, and only after I did a write operation on it all the values from <code>originalArray</code> were copied over to another memory address, so than the copy could be edited without changing anything at the original.</p><p>Since this all happens under the hood, in most cases it makes no practical difference if you are aware of this language characteristic. But maybe you have a really specific situation where you want to give more context to the code by reassigning one array to a different name, and now you know that you will be paying basically nothing for it in terms of memory usage.</p><p>Thank you for reading, take care, and good coding!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lucas1295santos.github.io/posts/first-post</guid><title>This blog is written in Swift!</title><description>Recently, I discovered [Publish](https://github.com/johnsundell/publish), a static website generator that uses Swift, written by [John Sundell](https://swiftbysundell.com).&lt;br&gt;&lt;/br&gt; The main idea is to declare all the pieces of your website like a *Swift Package*, and then using [Plot](https://github.com/JohnSundell/Plot) to generate HTML code using the type-safety of Swift, and finally using [Ink](https://github.com/JohnSundell/Ink) to render posts written in **Markdown**. (like this one!) &lt;br&gt;&lt;/br&gt; It may sound like a lot of tools to handle, but in reality, Publish already does most of the work for you.</description><link>https://lucas1295santos.github.io/posts/first-post</link><pubDate>Mon, 20 Apr 2020 00:00:00 -0300</pubDate><content:encoded><![CDATA[<h1>This blog is written in Swift!</h1><p>Recently, I discovered <a href="https://github.com/johnsundell/publish">Publish</a>, a static website generator that uses Swift, written by <a href="https://swiftbysundell.com">John Sundell</a>. The main idea is to declare all the pieces of your website like a <em>Swift Package</em> and then using <a href="https://github.com/JohnSundell/Plot">Plot</a> to generate HTML code using the type-safety of Swift, and finally using <a href="https://github.com/JohnSundell/Ink">Ink</a> to render posts written in <strong>Markdown</strong>. (like this one!) It may sound like a lot of tools to handle, but in reality, Publish already does most of the work for you.</p><p>Before digging into how Publish works, I highly recommend that you read the README of <a href="https://github.com/johnsundell/publish">Publish's Github</a> to have an overview on the framework, and all the step-by-step of how to <strong>install</strong> and <strong>setup</strong> a starter project.</p><p>It is worth noting that there you can find a <strong>HowTo</strong> folder where the community registers how to do things that they struggled at first but then figured it out.</p><h2>Files structure</h2><img src="https://raw.githubusercontent.com/lucas1295santos/lucas1295santos.github.io/master/images/post1_img1.png" alt="File structure" style="width:200px;"/><p>When you start a new <strong>Publish</strong> website, it will create a file structure like the one above. The first thing we'll do is to understand what is the basic website generated.</p><ul><li><em>Package.swift</em> is a file where you should declare dependencies for your project. If you never worked with Swift Package Manager, you can think of this file as a <em>Podfile</em> where you declare the <em>Cocoa pods</em> that you want to import. You also can learn more at this great article at <a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager/">Swift by Sundell</a>.</li></ul><ul><li><em>Content</em> is where you'll add posts, audio, video, or any type of content your website is about. This very blog post is currently in this folder.</li></ul><ul><li><em>Output</em> folder is generated after you run <code>publish generate</code>, and <strong>this is the actual website</strong>. You shouldn't really code or add anything here, Publish will generate everything when you use the <code>generate</code> command.</li></ul><ul><li><em>Resources</em> folder is where you can store assets that your pages will use, and <strong>CSS</strong> styles as well. Currently, I have a <em>images</em> and <em>css</em> folders here. The image of the file structure above is stored int this folder.</li></ul><ul><li><em>Sources</em> folder is where you'll code! Currently, there is a folder with your project's name and a <code>main.swift</code> inside.</li></ul><h2>main.swift</h2><p>This file declares your website through a structure that implements <code>Website</code>, and defines the publishing steps for it.</p><pre><code class="language-swift">struct Bla: Website {
    // Website configurations go here
}
</code></pre><p>And outside of the Website defining structure, you'll have the publish step. This is what will be executed on <code>publish deploy</code>.</p><pre><code class="language-swift">try Bla().publish(
  withTheme: .custom,
  additionalSteps: [
    .deploy(using: .git("git@github.com-lucas1295santos:lucas1295santos/lucas1295santos.github.io.git"))
  ]
)
</code></pre><p>On the example above I did a really basic publish workflow, where I use <strong>Github Pages</strong> to host this website and make it available at this domain. I also declare that I want to use a theme called <code>custom</code> to render this website (I'll talk about that in a bit). But this can easily become a robust deployment pipeline if your website needs to.</p><pre><code class="language-swift">try Bla().publish(using: [
    .step1(),
    .step2(),
    .step3()
])
</code></pre><h2>Custom theme</h2><p>To give your website some visual identity, you'll probably want to not use the default theme and create your own. I do this by instantiating a new <code>Theme</code> passing a <code>HTMLFactory</code> and the <strong>CSS</strong> resources that I'll use, making it available as a static variable of <code>Theme</code> just to make it easily accessible on my <strong>main.swift</strong>.</p><pre><code class="language-swift">extension Theme {
    static var custom: Self {
        Theme(
            htmlFactory: CustomHTMLFactory(),
            resourcePaths: ["Resources/css/styles.css"]
        )
    }
}
</code></pre><p>The <code>CustomHTLMFactory</code> on the code above is an implementation of the <code>HTMLFactory</code> protocol that generates the HTML layout for each piece of the website.</p><pre><code class="language-swift">private struct CustomHTMLFactory&lt;Site: Website&gt;: HTMLFactory {
    func makeIndexHTML(for index: Index, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeSectionHTML(for section: Section&lt;Site&gt;, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeItemHTML(for item: Item&lt;Site&gt;, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makePageHTML(for page: Page, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML {}
    
    func makeTagListHTML(for page: TagListPage, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML? {}
    
    func makeTagDetailsHTML(for page: TagDetailsPage, context: PublishingContext&lt;Site&gt;) throws -&gt; HTML? {}
}
</code></pre><p>I'll not dig any deeper on how to use <strong>Plot</strong> to create the HTML layout required on each method from <code>HTMLFactory</code>, but I highly recommend that you take a look at the implementation of the <code>foundation</code> theme (the one that comes with <strong>Publish</strong>) at the file <code>Theme+Foundation.swift</code> on the <code>Publish</code> package. Copy it, try to change it a little bit, and you will get a hang on how it works in no time (especially if you know any HTML).</p><h2>Wrapping up</h2><p>I'm excited about this framework, and it's being a joy to work with it! And I'm still learning everything that it can do, so I'll post more about it as I learn.</p><p>I Hope that this post gives you a good idea of what it is, and how to get started. And besides the documentations that I referenced throughout the post, you might want to check out <a href="https://youtu.be/JqdS-oi96Gk">this hands-on video</a> from Kilo Loco about getting started on Publish.</p><p>Thank you for reading, take care, and good coding!</p>]]></content:encoded></item></channel></rss>